<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title><![CDATA[Simplicity + Power = Elegance]]></title>
    <link>http://fancymax.github.io/</link>
    <atom:link href="//atom.xml" rel="self" type="application/rss+xml"/>
    <description></description>
    <pubDate>Sun, 24 Dec 2017 07:18:02 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title><![CDATA[猫咪生病记]]></title>
      <link>http://fancymax.github.io/2017/12/24/cat/</link>
      <guid>http://fancymax.github.io/2017/12/24/cat/</guid>
      <pubDate>Sun, 24 Dec 2017 06:55:34 GMT</pubDate>
      <description>
      <![CDATA[<h3 id="周二12月12日">周二12月12日</h3><p>猫咪晚上开始还和另一只猫咪打架跑来跑去，然后突然坐着不动，腹部激烈抖动，然后就开始吐带白泡沫的水。偶尔吐一下没在意。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<h3 id="周二12月12日">周二12月12日</h3><p>猫咪晚上开始还和另一只猫咪打架跑来跑去，然后突然坐着不动，腹部激烈抖动，然后就开始吐带白泡沫的水。偶尔吐一下没在意。</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2017/12/24/5a3f4cb2cac41.jpg" alt="1"></p>
<h3 id="周三12月13日">周三12月13日</h3><p>白天就吐了6次左右，以为是猫粮问题，因为之前吃的进口猫粮，后来换了国产量，不过也吃了半个月了。于是给开了一个罐头，后来发现吃啥吐啥，晚上也吐了4次左右。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4ce0189b4.jpg" alt="2"></p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4d06a62d6.jpg" alt="3"></p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4d396492b.jpg" alt="4"></p>
<h3 id="周四12月14日">周四12月14日</h3><p>白天已经只能喝水了，给它泡了葡萄糖水，但也吐，已经是黄水，晚上带去医院打点滴，消炎，补充能量，医生说可能有异物。从医院回来晚上12点多，它就一直蔫蔫的，心情不好，晚上吐了一次。</p>
<h3 id="周五12月15日">周五12月15日</h3><p>吐了一次，但是吃了几块小饼干，一些猫草，也小便了。</p>
<h3 id="周六">周六</h3><p>昨天带去拍片，医生说可能有异物，也不确定是什么，让做胰腺炎检查，或者吃钡餐，但是我看它能让人摸肚子，而且体温也正常，就没做胰腺炎检查，而且吃钡餐对肠胃也不好，医生也没告诉我哪里可能有异物，就让吃化毛膏，橄榄油，用开塞露。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4d6b6f263.jpg" alt="5"></p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4d8766531.jpg" alt="6"></p>
<p>随后这三样都用了，周六小便了，周日大便了，但是它还是不吃不喝不动，蔫蔫的。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4da227e1b.jpg" alt="7"></p>
<h3 id="周一12月18日">周一12月18日</h3><p>早上发现它吐了周末灌的化毛膏及自己吃的猫草。早上给它灌了舒化奶，鸡肉丝，乳果糖，晚上放他出来玩，又吐了早上喂的吃的。尿了一大泡，但是没有大便。又给他用了小半只开塞露，无果。晚上给它灌了牛奶，鸡肉丝，化毛膏，橄榄油，乳果糖。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4dbf0b278.jpg" alt="8"></p>
<h3 id="周二12月19">周二12月19</h3><p>早上给它灌了舒化奶，乳果糖，益生菌，没吐，没拉，晚上回去发现想吃东西了，闻了闻猫粮，煮的鸡肉，想吃，最后吃了小鱼饼干。吃晚饭时，主动跳到我腿上，想看看桌子上的吃的。晚上给它灌了橄榄油，半包益生菌，乳果糖，葡萄糖，很配合的吃了，吃完又不爱动了，总结，它一吃肉就吐。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4dea057de.jpg" alt="8"></p>
<h3 id="周三12月20日">周三12月20日</h3><p>早上给它灌舒化奶，非常抗拒，还抓伤了我，尽量给它多灌点。晚上拉了2次便便，看样子，喂的橄榄油拉出来了，还是不吃，就主动吃了一根草，给它喂了2杯牛奶，一点营养膏，益生菌，vb。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4e08eb1c7.jpg" alt="10"></p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4e22e8e01.png" alt="11"></p>
<h3 id="周四12月21日">周四12月21日</h3><p>没有吐，晚上回来，拉了小便，吃了10粒猫粮，几块小饼干，还自己洗脸了，给它煮了鸡肉，还吃了一小块，精神也好了很多，还想给蛋蛋舔屁股。但是没有吃益生菌。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4e3b8e217.png" alt="12"></p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4e54c730d.png" alt="12"></p>
<h3 id="周五12月22日">周五12月22日</h3><p>下午又吐了一小坨水，黄水，还有一根草，昨天晚上给它留的鸡肉，猫粮都么吃。晚上自己去磨爪子了，但是又开始不吃东西了，就吃了几块小饼干，又给灌了一杯羊奶，加了益生菌，葡萄糖，vb，vc，吗叮啉，阿莫西林。有小便，没有大便</p>
<h3 id="周六12月23">周六12月23</h3><p>今天上午给灌了20ml左右的羊奶，上午主动吃猫粮，对于小饼干很热衷，也自己喝水了，但是吃猫粮吃的不多，精神好了许多，自己磨爪子，洗脸，上下也窜动，但是活动一会就累了，有小便没有大便，晚上给灌了羊奶，加了益生菌，葡萄糖，vb，vc，吗叮啉，阿莫西林。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4e7210d1b.jpg" alt="14"></p>
<h3 id="周日12月24日">周日12月24日</h3><p>逗逗基本好了，能自己吃猫粮，能喝水，会玩玩具，会凑过来让你摸头，摸它，会咕噜咕噜响，而且拉了一坨完美的便便，基本没多大事了。</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4e9462750.jpg" alt="15"></p>
<p>总结下，逗逗开始吃雪山猫粮，后来双十一买的卡比没到，给它换了both猫粮，虽然这个猫粮它也吃过，但是当both猫粮吃完，给它换卡比的时候开始呕吐，所以有可能是因为肠胃不适应。</p>
<p>而在这个过程我们上网查资料，以为它有异物，看兽医，说他可能便秘或者吃了异物或者胰腺炎，幸好上午查阅了大量资料，它生病的那周上班都在看资料，然后也咨询了大量身边养猫同事，觉得它不可能是胰腺炎。也没让他吃钡餐，让他免于挨一刀。</p>
<p>在治疗过程发现，消炎药，益生菌，羊奶或者舒化奶不错，而且阳光也不错，逗逗开始晒了太阳之后开始变好了，虽然这些都是不专业人士的自我揣测，虽然逗逗还是很虚弱，但是以前身体健康时各类表现都有了，以后好好照顾，加强就好啦。</p>
<p>曾经一度以为逗逗熬不到今年圣诞，熬不到它一岁生日，但它还是坚持下来啦，为他的坚强点赞～也为每天早起喂奶，晚上一下班就回来喂奶的自己点赞～愿每个动物都能得到珍惜～</p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4eb558f23.jpg" alt="20"></p>
<p><img src="https://i.loli.net/2017/12/24/5a3f4ecc74acc.jpg" alt="21"></p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2017/12/24/cat/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[开源直播工具OBS研究]]></title>
      <link>http://fancymax.github.io/2017/10/28/obs/</link>
      <guid>http://fancymax.github.io/2017/10/28/obs/</guid>
      <pubDate>Sat, 28 Oct 2017 11:03:17 GMT</pubDate>
      <description>
      <![CDATA[<h1 id="项目简介">项目简介</h1><p>OBS - Free and open source software for live streaming and screen recording(OBS是一款开源的用于录屏直播的工具软件)。</p>
<p>旧版的OBS只能]]>
      </description>
      <content:encoded><![CDATA[<h1 id="项目简介">项目简介</h1><p>OBS - Free and open source software for live streaming and screen recording(OBS是一款开源的用于录屏直播的工具软件)。</p>
<p>旧版的OBS只能支持Windows，目前已经停止开发。作者为了支持Windows/Mac/Linux重写了整个软件，项目地址为<a href="https://github.com/jp9000/obs-studio" target="_blank" rel="external">obs-studio in Github</a>。</p>
<p>新版的OBS的目标有以下几点：</p>
<ol>
<li>Make it multiplatform.(<strong>跨平台支持</strong>)</li>
<li>Separate the application from the core, allowing custom application of the core if desired, and easier extending of the user interface.(<strong>模块化、易扩展</strong>)</li>
<li>Simplify complex systems to not only make it easier to use, but easier to maintain.(<strong>简化系统，使其易用易维护</strong>)</li>
<li>Make a better/cleaner code base, use better coding standards, use standard libraries where possible (not just STL and C standard library, but also things like ffmpeg as well), and improve maintainability of the project as a whole.(<strong>尽量利用其他开源软件成果</strong>)</li>
<li>Implement a new API-independent shader/effect system allowing better and easier shaders usage and customization without having to duplicate shader code.(<strong>实现独立于API的shader/effect系统</strong>)</li>
<li>Better device support.  (<strong>更好的支持有录屏需求的设备</strong>)</li>
</ol>
<p>OBS项目的语言分布：</p>
<ol>
<li>C: 57.6%</li>
<li>C++: 36.3%</li>
<li>Objective-C/Objective-C++: 4%</li>
<li>others: 3%</li>
</ol>
<p>OBS代码主要包含这些部分：</p>
<ol>
<li>libobs: 核心代码，定义项目框架以及核心API，主要用C语言编写。</li>
<li>UI: 界面代码，采用C++的QT框架，开发出适用三大平台的界面。</li>
<li>plugins: 插件代码，可独立编译成dll(windows平台)或so(*nix平台)，包含Source(录屏输入源)、Output、Service(各种流播服务)等全部被定义为插件。</li>
<li>libobs-d3d11: 基于D3D的图形子系统，主要用在Windows系统。</li>
<li>libobs-opengl: 基于opengl的图形子系统，主要用在*uix系统。</li>
</ol>
<h2 id="OBS软件功能概述">OBS软件功能概述</h2><p>OBS项目工程中以场景组的方式呈现给用户,可以自由设置场景、输入源、效果处理，配置直播服务。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016121483032obs_ui.png" alt="2016121483032obs_ui.png"></p>
<h3 id="OBS项目工程结构">OBS项目工程结构</h3><p>OBS项目中一个工程结构如下<img src="http://7xpbra.com1.z0.glb.clouddn.com/201612147022obs_project_stucture.png" alt="201612147022obs_project_stucture.png"></p>
<p>一个场景组包含多个场景，OBS直播的时候是把整个场景流播给用户，那为什么需要多个场景？因为播主在直播时有快速切换场景的需要，所以播主需要在直播前编辑好多个场景(比如纯游戏场景；游戏+头像；解说；休息场景等)，然后直播的过程中可以根据不同的需要快速切换。</p>
<h3 id="OBS场景的转场">OBS场景的转场</h3><p>OBS中的转场，是场景切换时的动画效果，目前支持 Fade和Switch等多种效果。</p>
<h3 id="OBS输入源的种类">OBS输入源的种类</h3><p>一个场景可以包含多个输入源，一个直播工具可以支持的输入源种类反应了其强大性。OBS支持 输入源种类如下<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016121460496obs_source_type.png" alt="2016121460496obs_source_type.png"></p>
<h3 id="OBS输入源的效果设置">OBS输入源的效果设置</h3><p>针对每个输入源可以增加各种滤镜效果,以下列出我觉得最实用的几种：<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122283761OBS_Effect.png" alt="2016122283761OBS_Effect.png"></p>
<ol>
<li>音频效果：<ol>
<li>Video Delay: 设置延迟时间，用来处理音视频不同步的的场景。</li>
<li>Noise Suppression: 噪音抑制</li>
<li>Gain: 音频增益</li>
<li>Noise Gate: 噪声门，把小噪音去掉</li>
</ol>
</li>
<li>视频效果:<ol>
<li>Crop: 就是最实用的Crop，不过OBS里不能用鼠标拖拽来控制Crop区域，略显不便</li>
<li>Chroma Key: 如果有绿幕背景，可以用来去背景，在摄像头的输入源中最常用。</li>
<li>Image Mask: 打水印</li>
<li>Scroll: 滚动效果，在一些浏览器的输入源上最实用。</li>
</ol>
</li>
</ol>
<h3 id="OBS工作室模式">OBS工作室模式</h3><p><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122215478OBS_StdioMode.png" alt="2016122215478OBS_StdioMode.png"><br>左边是预览界面，可以进行编辑。右边是正在直播的界面。中间是把预览界面切到直播界面的各种转场效果。</p>
<p>一般比较专业的直播都是使用这个模式，可以在预览界面编辑好画面之后再推送到直播画面。</p>
<h2 id="OBS插件系统">OBS插件系统</h2><p>OBS项目中把除了核心框架以及渲染系统之外的 部件全部抽象成了Module，一个或多个Module最后封装到插件中(以dll或so的形式)，只要把插件放入特定的目录即可被主程序使用。</p>
<p>Mac版OBS的插件目录在/Applications/OBS.app/Contents/Resources/obs-plugins,其中</p>
<ol>
<li>mac-avcapture.so 对应Mac的视频捕获设备</li>
<li>mac-capture.so 对应屏幕捕获 和 窗口捕获</li>
<li>mac-syphon.so 对应注入捕获游戏画面</li>
</ol>
<h3 id="OBS插件定义">OBS插件定义</h3><p>一个典型的OBS插件代码包含三个部分：</p>
<ol>
<li>插件定义 -&gt; plugin-main.c</li>
<li>编译打包 -&gt; CMakeList.txt</li>
<li>内部实现代码 -&gt; XX.c/YY.c …</li>
</ol>
<p>下面以mac-capture.so插件为例来看看它的插件定义代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;obs-module.h&gt;</span></span><br><span class="line"></span><br><span class="line">OBS_DECLARE_MODULE()</span><br><span class="line">OBS_MODULE_USE_DEFAULT_LOCALE(<span class="string">"mac-capture"</span>, <span class="string">"en-US"</span>) <span class="comment">//多语言支持</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> obs_source_info coreaudio_input_capture_info; <span class="comment">//输入源1</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> obs_source_info coreaudio_output_capture_info;<span class="comment">//输入源2</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> obs_source_info display_capture_info;<span class="comment">//输入源3</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">struct</span> obs_source_info window_capture_info;<span class="comment">//输入源4</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">obs_module_load</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//注册支持的输入源</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	obs_register_source(&amp;coreaudio_input_capture_info);</span><br><span class="line">	obs_register_source(&amp;coreaudio_output_capture_info);</span><br><span class="line">	obs_register_source(&amp;display_capture_info);</span><br><span class="line">	obs_register_source(&amp;window_capture_info);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出这个插件定义了四个输入源，这里你可能有个疑问，为什么不是一个插件 对应 一个输入源，因为功能相近的输入源集成到一个插件里可以减少冗余代码。</p>
<p>所以OBS中插件可以定义为 包含 一个 或 多个 输入(或 输出/编码/服务)模块的动态库代码。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016121549583obs_module_define.png" alt="2016121549583obs_module_define.png"><br>任意一个开源库比如FFmpeg,经过OBS统一的接口定义封装即可编译成OBS的一个插件为OBS系统所用。</p>
<h3 id="OBS插件加载流程">OBS插件加载流程</h3><p>插件系统大体都有一个类似的套路，OBS的也不例外。简单来说就是定义插件存放在特定目录，在程序启动时，动态加载所有的插件(存储为对象或一系列函数指针)，存储在字典 或者 链表这样的数据结构里。</p>
<p>下面来详细分析一下OBS中插件加载流程：<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016121573630OBS_import_module-2.png" alt="2016121573630OBS_import_module-2.png"></p>
<p>然后以mac-capture.so中的display_capture_info，来看看它的结构定义,可以看出它主要定义了id、type、name 以及一些接口API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> obs_source_info display_capture_info = &#123;</span><br><span class="line">	.id             = <span class="string">"display_capture"</span>,</span><br><span class="line">	.type           = OBS_SOURCE_TYPE_INPUT,</span><br><span class="line">	.get_name       = display_capture_getname,</span><br><span class="line"></span><br><span class="line">	.create         = display_capture_create,</span><br><span class="line">	.destroy        = display_capture_destroy,</span><br><span class="line"></span><br><span class="line">	.output_flags   = OBS_SOURCE_VIDEO | OBS_SOURCE_CUSTOM_DRAW |</span><br><span class="line">	                  OBS_SOURCE_DO_NOT_DUPLICATE,</span><br><span class="line">	.<span class="keyword">video_t</span>ick     = <span class="keyword">display_capture_video_t</span>ick,</span><br><span class="line">	.video_render   = display_capture_video_render,</span><br><span class="line"></span><br><span class="line">	.get_width      = display_capture_getwidth,</span><br><span class="line">	.get_height     = display_capture_getheight,</span><br><span class="line"></span><br><span class="line">	.get_defaults   = display_capture_defaults,</span><br><span class="line">	.get_properties = display_capture_properties,</span><br><span class="line">	.update         = display_capture_update,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中需要注意一下get_properties这个接口，这个接口是干啥用的？顾名思义是获取模块的属性数据，按我的理解 UI层可以利用这个属性数据来构建这个模块对应的界面，并设置这个模块的属性参数。</p>
<h3 id="OBS视频处理流程">OBS视频处理流程</h3><h4 id="视频渲染输出流程">视频渲染输出流程</h4><p>OBS视频渲染和输出是系统的核心流程，我们以Mac桌面录制输入，以及ffmpeg输出为例来分析一下整个流程(多路输入 和 多路输出道理也是类似的), 图中为了简单起见忽略了输出编码流程仅包含非编码流程。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122060378OBS_Video_Render_2.png" alt="2016122060378OBS_Video_Render_2.png"><br>可以看出OBS创建了两个线程，一个用于显示渲染，另一个用于编码输出。<br>渲染部分最终调用的是 输入模块里的渲染代码，而编码输出部分最终也是调用 输出模块的代码。</p>
<p><strong>另外在渲染线程中 也负责把图形系统的数据 拷贝到 输出数据的缓存中，以便于输出线程进行处理</strong>。</p>
<h4 id="视频输出数据结构分析">视频输出数据结构分析</h4><p>OBS的核心数据结构定义在libobs/obs-internal.h中 主体结构为obs_core如下图所示(仅保留的主要的数据结构)<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016121631085OBS_CoreVideo-2.jpg" alt="2016121631085OBS_CoreVideo-2.jpg"></p>
<p>右下方的video(结构为video_output)用在输出模块的raw_video接口进行处理，把 输出数据中的cache转成实际的输出，以下是video_output详细数据结构：<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016121665597OBS_Video_detail_2.jpg" alt="2016121665597OBS_Video_detail_2.jpg"></p>
<h3 id="OBS音频处理流程">OBS音频处理流程</h3><p>OBS音频处理是在一个线程中完成了先渲染后输出的过程。而视频处理则是 分别开了渲染线程 和 输出线程。</p>
<p>具体流程如下, 在输出函数中在判断是否需要编码，再调用对应的非编码流程 或 编码流程：<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122068454OBS_Audio_Render.png" alt="2016122068454OBS_Audio_Render.png"></p>
<h1 id="OBS图形系统架构">OBS图形系统架构</h1><p>OBS的图形系统主要负责 场景的渲染、场景的切换、以及各种输入源的音视频效果的处理，属于OBS的核心之一。<br>通过使用软件以及视频渲染流程的分析 得到OBS图形系统的大体的逻辑关系。</p>
<p><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122324058OBS_Graphic_Structure_1.png" alt="2016122324058OBS_Graphic_Structure_1.png"></p>
<p>针对图形系统主要分析以下三个问题：</p>
<ol>
<li>多滤镜叠加的渲染处理。</li>
<li>滤镜和转场效果的实现与集成。</li>
<li>图形API的封装。</li>
</ol>
<h2 id="单个场景的渲染流程">单个场景的渲染流程</h2><p>场景(Scene)也被封装成输入源(Source)的一种,所以UI层只要把当前的场景取出来，调用它的obs_source_video_render即可。</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017011791095OBS_sceneRender.png" alt="2017011791095OBS_sceneRender.png"></p>
<p>在场景内部会渲染其包含的renderitem(也就是实际的输入源),比如前一个图所展示的游戏录制、桌面录制输入源等。</p>
<h2 id="多个滤镜叠加的输入源渲染流程">多个滤镜叠加的输入源渲染流程</h2><p>这部分分析了很长时间一直没看懂，主要有两个原因：</p>
<ol>
<li>之前不熟悉OpenGl的渲染流程，所以搞不懂滤镜的渲染流程。</li>
<li>这部分的逻辑比较绕，没分析出多个滤镜是怎么叠加渲染的。</li>
</ol>
<p>前段时间花了点时间好好学习了一下OpenGl(仅仅学习和音视频处理相关的章节)，写了一些<a href="https://github.com/fancymax/LearnOpenGL_Mac" target="_blank" rel="external">demo</a>。</p>
<p>现在再来分析这部分相对轻松一些，简述一下：当渲染带滤镜的输入源时，会先渲染它最后一个滤镜，然后在这个滤镜的渲染代码又会调用渲染前一个滤镜，最后调用第一个滤镜的渲染代码。</p>
<p>在第一个滤镜的渲染代码里 直接渲染 调用输入源的渲染流程，然后生成texture。</p>
<p>每个滤镜都在前一个滤镜渲染生成的texture的基础渲染生成新的texture。</p>
<p>流程图如下：<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017011799373OBS_filterRender.png" alt="2017011799373OBS_filterRender.png"></p>
<h2 id="滤镜和转场效果的实现与集成">滤镜和转场效果的实现与集成</h2><p>OBS项目中，滤镜和转场效果都被抽象成插件。</p>
<p>以Mac版OBS为例:</p>
<ol>
<li>所有的滤镜都在obs-filters.so这个插件里;</li>
<li>所有的转场效果都在obs-transitions.so里;</li>
</ol>
<p>滤镜和转场其实分析起来是类似的，所以后续的暂时以滤镜为例来加以说明。</p>
<p>首先如果滤镜个数太多，拆分到两个插件里是没问题的。不过OBS项目中全部集中在一个插件里。</p>
<p>每个滤镜其实都被定义成了输入模块，以obs_source_info定义暴露API，以crop_filter为例见如下定义，唯一和普通输入模块不同的是类型定义(.type)。 </p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct obs_source_info <span class="variable">crop_filter =</span> &#123;</span><br><span class="line">	.<span class="variable">id                            =</span> <span class="string">"crop_filter"</span>,</span><br><span class="line">	.<span class="variable">type                          =</span> OBS_SOURCE_TYPE_FILTER,</span><br><span class="line">	.<span class="variable">output_flags                  =</span> OBS_SOURCE_VIDEO,</span><br><span class="line">	.<span class="variable">get_name                      =</span> crop_filter_get_name,</span><br><span class="line">	.<span class="variable">create                        =</span> crop_filter_create,</span><br><span class="line">	.<span class="variable">destroy                       =</span> crop_filter_destroy,</span><br><span class="line">	.<span class="variable">update                        =</span> crop_filter_update,</span><br><span class="line">	.<span class="variable">get_properties                =</span> crop_filter_properties,</span><br><span class="line">	.<span class="variable">get_defaults                  =</span> crop_filter_defaults,</span><br><span class="line">	.<span class="variable">video_tick                    =</span> crop_filter_tick,</span><br><span class="line">	.<span class="variable">video_render                  =</span> crop_filter_render,</span><br><span class="line">	.<span class="variable">get_width                     =</span> crop_filter_width,</span><br><span class="line">	.<span class="variable">get_height                    =</span> crop_filter_height</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>细心观察每个滤镜的代码组成发现都是一个套路,主要由两部分组成:</p>
<ol>
<li>XXX.c  (C代码，用于暴露API以及例行处理)</li>
<li>XXX.effect (自定义文件，实际效果处理逻辑)</li>
</ol>
<p>关于这个effect留到后续讲解。</p>
<p>看到这里得出一个结论，OBS项目要增加新的滤镜效果只要编写对应的XXX.c 和 XXX.effect，放到对应的插件以输入模块的API暴露出来，并注册就可以了。</p>
<h2 id="图形API的封装处理">图形API的封装处理</h2><p>目前OBS系统的图形API包括OpenGl以及d3d11:</p>
<ol>
<li>在图形库加载层利用了<a href="https://github.com/Dav1dde/glad" target="_blank" rel="external">Multi-Language GL/GLES/EGL/GLX/WGL Loader-Generator</a>对不同平台加载图形库代码进行了封装。</li>
<li>在API调用层面也进行了抽象统一，具体可以查看 libobs/graphics/graphics-imports.c的定义。</li>
<li>自定义了效果描述文件 XXX.effect，这样就不用针对OpenGl和d3d11写两遍Shader。</li>
</ol>
<p>我们以chroma-key-filter为例分析一下它的创建流程:<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122616450OBS_filter_create.png" alt="2016122616450OBS_filter_create.png"></p>
<ol>
<li>其中AddNewFilter是在界面中触发的添加效果的功能。</li>
<li>ep_parse把xxx.effect配置文件解析成对应的配置结构。</li>
<li>ep_compile把对应的配置结构解析 效果数据结构。</li>
</ol>
<p>effect文件的作用可以参考程序中的注释</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Effects introduce a means <span class="keyword">of</span> bundling together shader <span class="type">text</span> <span class="keyword">into</span> one</span><br><span class="line"> * <span class="type">file</span> <span class="keyword">with</span> shared functions <span class="keyword">and</span> parameters.  This <span class="keyword">is</span> done because often</span><br><span class="line"> * shaders must be duplicated when you need <span class="keyword">to</span> alter minor aspects <span class="keyword">of</span> <span class="keyword">the</span> code</span><br><span class="line"> * <span class="keyword">that</span> cannot be done via constants.  Effects allow developers <span class="keyword">to</span> easily</span><br><span class="line"> * switch shaders <span class="keyword">and</span> <span class="keyword">set</span> constants <span class="keyword">that</span> can be used <span class="keyword">between</span> shaders.</span><br><span class="line"> *</span><br><span class="line"> * Effects are built via <span class="keyword">the</span> effect parser, <span class="keyword">and</span> shaders are automatically</span><br><span class="line"> * generated <span class="keyword">for</span> each technique's pass.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>effect文件包括这几个部分:<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2016122616242effect_file_structure.png" alt="2016122616242effect_file_structure.png"></p>
<p>pass对应 vertex_shader 和 pixel_shader</p>
<p>technique 对应一个具体效果的渲染设置，包含多个pass</p>
<p>effect文件包含多个technique渲染设置、可以共享文件中的参数和函数。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SolidVertInOut VSSolid(SolidVertInOut vert<span class="number">_</span><span class="keyword">in</span>)</span><br><span class="line">&#123;</span><br><span class="line">	SolidVertInOut vert<span class="number">_</span><span class="keyword">out</span>;</span><br><span class="line">	vert<span class="number">_</span><span class="keyword">out</span>.pos = mul(float<span class="number">4</span>(vert<span class="number">_</span><span class="keyword">in</span>.pos.xyz, <span class="number">1.0</span>), ViewProj);</span><br><span class="line">	<span class="keyword">return</span> vert<span class="number">_</span><span class="keyword">out</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float<span class="number">4</span> PSSolid(SolidVertInOut vert<span class="number">_</span><span class="keyword">in</span>) : TARGET</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">technique Solid</span><br><span class="line">&#123;</span><br><span class="line">	pass</span><br><span class="line">	&#123;</span><br><span class="line">		vertex<span class="number">_</span>shader = VSSolid(vert<span class="number">_</span><span class="keyword">in</span>);</span><br><span class="line">		pixel<span class="number">_</span>shader  = PSSolid(vert<span class="number">_</span><span class="keyword">in</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>effect文件支持基本的C语法，支持宏定义和include包含其他文件，由libobs/util中的cf-lexer.c和cf-parser.c提供解析支持。</p>
<h1 id="支持OBS插件">支持OBS插件</h1><p>OBS的插件是在OBS项目定义的比较宽泛，插件的范畴包括 整个录屏、处理、推流 中的各个功能模块.</p>
<p>如果我们的软件中可以直接支持OBS插件，就可以节省大量的开发、测试的时间。但由于我们的程序框架和OBS的完全不同，要如何支持OBS项目的插件呢？</p>
<p>想了两种方法，并尝试分析一下优缺点。</p>
<h2 id="支持OBS的方法分析">支持OBS的方法分析</h2><h3 id="二进制级别的支持">二进制级别的支持</h3><p>顾名思义，就是把OBS的插件直接放到我们程序的相应目录就可以用。这种方式下维护、更新、新增 OBS插件 代价是最小的。也是我心中理想的支持方式。</p>
<p>但是以这种方式支持的遇到较大困难。先看OBS项目中的代码的各个模块：</p>
<ol>
<li>libobs: 核心代码，定义项目框架以及核心API，主要用C语言编写。</li>
<li>UI: 界面代码，采用C++的QT框架，开发出适用三大平台的界面。</li>
<li>plugins: 插件代码，可独立编译成dll(windows平台)或so(*nix平台)，包含Source(录屏输入源)、Output、Service(各种流播服务)等全部被定义为插件。</li>
<li>libobs-d3d11: 基于D3D的图形子系统，主要用在Windows系统。</li>
<li>libobs-opengl: 基于opengl的图形子系统，主要用在*uix系统。</li>
</ol>
<p>我们想要支持plugins中的插件，</p>
<p>但是plugins中的插件要依赖libobs，</p>
<p>而libobs又要依赖libobs-opengl 和 QT界面库。</p>
<p>也就是除非 我们的项目支持基于OBS项目改写，否则这种支持方式的不太现实。</p>
<h3 id="代码级别的支持">代码级别的支持</h3><p>这是退而求其次的方式，简单的说就是把OBS的插件代码扣出来，确保其不依赖于libobs，然后集成我们的项目中。这种方式每支持一个插件都存在集成的工作量，也可能会引入Bug，不过不失为一个较为可行的方案。</p>
<h3 id="OBS项目编译">OBS项目编译</h3><p>尝试了在Mac平台上编译OBS项目，还比较顺利。具体可以参考<a href="https://github.com/jp9000/obs-studio/wiki/Install-Instructions#mac-osx" target="_blank" rel="external">install help</a></p>
<p>有个小问题，在cmake后报错提示无法找到QT5的cmake模块。需要给cmake指定一下QT5的安装目录，以我的安装目录为例，命令如下：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake .. -DCMAKE_PREFIX_PATH=<span class="regexp">/usr/</span>local<span class="regexp">/Cellar/</span>qt5<span class="regexp">/5.3.1/</span></span><br></pre></td></tr></table></figure></p>
<p>cmake命令我是不熟悉的，不过看了<a href="http://hahack.com/codes/cmake/" target="_blank" rel="external">这篇文章</a>也基本懂了。</p>
<p>OBS项目最后的编译结果如下：</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/201702058452OBS_Compile.png" alt="201702058452OBS_Compile.png"></p>
<p>主要有三个目录：</p>
<ol>
<li>bin:  主程序</li>
<li>data: 国际化资源 以及 视频effect效果资源</li>
<li>obs-plugin: 插件编译结果</li>
</ol>
<p>使用otool -L分析中其中主要动态库和插件(仅以mac-capture为例)的依赖关系如下:</p>
<p><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017020524659OBS_dependency.png" alt="2017020524659OBS_dependency.png"></p>
<p>前面在代码层面分析直接二进制支持OBS插件感觉很困难。但这里基于编译后的动态库依赖关系分析好像又有一定可行性。我们把mac-capture.so、libobs.0.dylib、ffmpeg独立出来，去掉OBS主程序和QT等库，自己写代码来调用libobs.0.dylib提供的功能，以此直接支持OBS的插件。</p>
<p>后续进行完相关的实验，看看到底是否可行，再来补充。</p>
<h3 id="模块列表">模块列表</h3><p>OBS项目中类型为OBS_SOURCE_TYPE_INPUT是我们可以考虑优先支持的模块。以下是功能说明。</p>
<table>
<thead>
<tr>
<th style="text-align:center">插件</th>
<th style="text-align:center">子模块</th>
<th style="text-align:center">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mac-capture</td>
<td style="text-align:center">coreaudio_input_capture</td>
<td style="text-align:center">音频输入获取</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">coreaudio_output_capture</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">display_capture</td>
<td style="text-align:center">桌面获取</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">window_capture</td>
<td style="text-align:center">窗体获取</td>
</tr>
<tr>
<td style="text-align:center">mac-avcapture</td>
<td style="text-align:center">av_capture</td>
<td style="text-align:center">摄像头获取</td>
</tr>
<tr>
<td style="text-align:center">mac-syphon</td>
<td style="text-align:center">syphon</td>
<td style="text-align:center">程序注入获取界面</td>
</tr>
<tr>
<td style="text-align:center">obs-ffmpeg</td>
<td style="text-align:center">ffmpeg_source</td>
<td style="text-align:center">ffmpeg输入源</td>
</tr>
<tr>
<td style="text-align:center">obs-browser</td>
<td style="text-align:center">browser_source</td>
<td style="text-align:center">浏览器输入</td>
</tr>
<tr>
<td style="text-align:center">text-freetype2</td>
<td style="text-align:center">freetype2_source</td>
<td style="text-align:center">text输入</td>
</tr>
<tr>
<td style="text-align:center">decklink</td>
<td style="text-align:center">decklink-input</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">image-source</td>
<td style="text-align:center">image_source</td>
<td style="text-align:center">图片输入</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">slideshow</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">vlc-video</td>
<td style="text-align:center">vlc_source</td>
<td style="text-align:center">vlc输入</td>
</tr>
</tbody>
</table>
<h1 id="mac-syphon插件分析">mac-syphon插件分析</h1><p>mac-syphon是OBS项目中用于获取游戏画面(仅用于mac平台)的插件，十分重要。下面来分析一下它的实现原理。</p>
<p>首先mac-syphon是OBS的输入源插件，所以遵循OBS的插件API设定，具体可以查看OBS插件分析章节的介绍。<br>mac-syphon内部其实组合了多个开源项目功能来完成:获取游戏画面，并展示到OBS界面上的功能。</p>
<p>我们以OBS获取MineCraft这个游戏的画面为例，来看一张总的实现原理图:<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/2017010524004OBS_SyphonInject.png" alt="2017010524004OBS_SyphonInject.png"></p>
<p>简单解释一下这个过程：</p>
<p><img src="http://7xpbra.com1.z0.glb.clouddn.com/2017010568862OBS_SyphonInject_flow.png" alt="2017010568862OBS_SyphonInject_flow.png"></p>
<p>注入游戏进程的方法这里用的是Scripting Additions的方式，这是macOS独有的技术，windows上肯定要用其他方式，到时候再单独研究。除了注入方式的区别，其他流程Win和Mac平台应该类似的。</p>
<p>另外由于注入的函数中替换的是OpenGL的渲染API，所以这个插件支持的游戏必然是使用OpenGL渲染的。假如某个程序或游戏不使用OpenGL则无法注入。</p>
<h2 id="ScriptingAdditions">ScriptingAdditions</h2><p>ScriptingAdditions就是macOS中Applescript中一个技术，不太好解释，反正它的作用就是帮助注入到游戏进程里，直接上两个文档:</p>
<ol>
<li><a href="https://developer.apple.com/library/content/technotes/tn1164/_index.html" target="_blank" rel="external">Scripting Additions for Mac OS X</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/AppleScript/Conceptual/AppleScriptX/Concepts/osa.html" target="_blank" rel="external">Open Scripting Architecture</a></li>
</ol>
<h2 id="mach_override">mach_override</h2><p>这里其实利用了两个项目<a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="external">jrswizzle</a>和<a href="https://github.com/rentzsch/mach_override" target="_blank" rel="external">mach_override</a>,功能就是把游戏进程中的flushBuffer替换为自己写的flushBufferSyphon，把orig_CGLFlushDrawable替换为CGLFlushDrawableOverride，从而实现把自己写的功能注入到游戏的渲染API中。</p>
<h2 id="Syphon">Syphon</h2><p><a href="https://github.com/Syphon" target="_blank" rel="external">Syphon</a>项目是一套传输图形画面的Client/Server框架。</p>
<p>项目还提供了<a href="https://github.com/Syphon/Simple" target="_blank" rel="external">Client/Server Demo</a>可以很方便的测试画面传输的功能。</p>
<h2 id="Syphon_Inject">Syphon Inject</h2><p><a href="https://github.com/zakk4223/SyphonInject" target="_blank" rel="external">SyphonInject</a>项目组合Syphon的功能以及注入游戏的功能，提供了一个Demo。</p>
<p>下图中我用Syphon Inject注入到Dota2游戏，然后把界面传送给<a href="https://github.com/Syphon/Simple" target="_blank" rel="external">Client Demo</a>。</p>
<p><img src="http://7xpbra.com1.z0.glb.clouddn.com/2017010588377SyphonInject_1.png" alt="2017010588377SyphonInject_1.png"></p>
<p><img src="http://7xpbra.com1.z0.glb.clouddn.com/2017010548405SyphonInject_2.png" alt="2017010548405SyphonInject_2.png"></p>
<p><strong>SyphonInject编译注意事项</strong>: SyphonInject项目早期利用mach_inject项目进行注入，后期已经修改为ScriptingAdditions方式注入。最新的代码没有依赖mach_inject，所以可以把mach_inject项目依赖去掉再编译。</p>
<p>最后OBS项目其实上述项目组合，用插件的API包装成了mac-Syphon插件。</p>
<h1 id="mac-capture插件分析">mac-capture插件分析</h1><p>mac-capture插件是OBS项目中对应mac平台的 屏幕界面获取、窗口界面获取、输入音频获取、输出音频获取 四大模块的具体实现。</p>
<p>obs模块的具体结构和API不再列出，详细情况可查看之前的文档，这里着重分析模块内部的功能实现。</p>
<h2 id="mac-display模块">mac-display模块</h2><p>主要利用<a href="https://developer.apple.com/reference/coregraphics/1655858-quartz_display_services" target="_blank" rel="external">Quartz Display Services</a>获取界面图像数据转换成texuture提供给主程序。</p>
<p>其中调用CGDisplayStreamCreateWithDispatchQueue接口获取的显示界面图像数据，数据结构是IOSurfaceRef。具体用法可以查看上述Quartz Display Services链接文档。</p>
<p>主要的实现流程如下图：<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017011827400OBS_macDisplay.png" alt="2017011827400OBS_macDisplay.png"></p>
<h2 id="mac-window-capture模块">mac-window-capture模块</h2><p>获取其他程序窗体界面的模块，也是利用了Quartz Display Services。</p>
<p>使用CGWindowListCreateImage接口，通过windowID把对应程序的界面以 CGImage 的形式返回,直接放到输出的Cache里。</p>
<p>这里有个疑问，模块没有实现.video_render这个渲染API。可能和模块的output_flags设置的是异步有关。<br>OBS_SOURCE_ASYNC_VIDEO异步的渲染流程可能未放到模块内部实现。</p>
<h2 id="mac-audio模块">mac-audio模块</h2><p>音频模块包括两个，音频输入模块 和 音频输出模块。</p>
<p>音频输入设备比如 iMac上自带的外置麦克风；音频输出模块 比如 插入的耳机等。</p>
<p>由于mac平台限制，无法直接录制 音频输出设备的声音。比如我要录制浏览器上youtube视频的声音，在不借助第三方程序的情况下是做不到。使用OBS也做不到。</p>
<p>不过利用第三方开源程序soundflower可以解决这个问题。在安装soundflower之后，OBS可以设置 音频输出捕获模块，设备选择soundflower。同时系统声音输出设备 也选择为soundflower。<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017011845343OBS_audioOutput.png" alt="2017011845343OBS_audioOutput.png"><br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017011866291OBS_audioOutput1.png" alt="2017011866291OBS_audioOutput1.png"></p>
<p>这样系统的任何程序发出的声音就会先经过soundflower，然后被OBS捕获。</p>
<p>mac-audio中的音频输入模块 和 输出模块 实现流程基本相同，如下所示：<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017011826851obs_macAudio.png" alt="2017011826851obs_macAudio.png"></p>
<p>基本原理是 在初始化模块的时候 使用系统接口AudioObjectAddPropertyListener注册音频的回调函数。然后在回调函数中完成音频渲染以及输出音频数据缓存。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2017/10/28/obs/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[写给大家看的设计书]]></title>
      <link>http://fancymax.github.io/2017/04/06/book201704/</link>
      <guid>http://fancymax.github.io/2017/04/06/book201704/</guid>
      <pubDate>Thu, 06 Apr 2017 14:27:48 GMT</pubDate>
      <description>
      <![CDATA[<ul>
<li><p>一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，使它在你的控制中。</p>
<ul>
<li>所以凡事要先掌握概念</li>
</ul>
</li>
<li><p>尽管我在后面将逐个讨论各个原则，不过要记住，它们实际上是相互关联的。只]]>
      </description>
      <content:encoded><![CDATA[<ul>
<li><p>一旦能够说出什么东西的名字，就会很容易注意到它。你就会掌握它，拥有它，使它在你的控制中。</p>
<ul>
<li>所以凡事要先掌握概念</li>
</ul>
</li>
<li><p>尽管我在后面将逐个讨论各个原则，不过要记住，它们实际上是相互关联的。只应用某一个原则的情况很少。</p>
<ul>
<li>4大设计原则是互相关联的</li>
</ul>
</li>
<li><p>亲密性的思想并不是说所有一切都要更靠近，其真正的含义是：如果某些元素在理解上存在关联，或者相互之间存在某种关系，那么这些元素在视觉上也应当有关联。除此以外，其他孤立的元素或元素组则不应存在亲密性。</p>
</li>
<li><p>要有意识地注意你是怎样阅读的，你的视线怎样移动：从哪里开始；沿着怎样的路径；到哪里结束；读完之后，接下来看哪里？整个过程应当是一个合理的过程，有确定的开始，而且要有确定的结束。</p>
</li>
<li><p>亲密性的根本目的是实现组织性。</p>
</li>
<li><p>利用亲密性原则，还可以使空白（这是设计者们最喜欢的）更美观（也更有条理）。</p>
</li>
<li><p>微微眯起眼睛，统计你的眼睛停顿的次数来数一数页面上有多少个元素。如果页面上的项超过3～5个（当然，这取决于具体情况），就要看看哪些孤立的元素可以归在一组建立更近的亲密性，使之成为一个视觉单元。</p>
</li>
<li><p>避免一个页面上有太多孤立的元素。</p>
</li>
<li><p>请注意你喜欢的那些设计。我敢保证，大多数看来精巧的设计都没有采用居中对齐。我知道，作为一个初学者，要完全摒弃居中对齐会很难，但你必须从一开始就强制自己避开它。通过充分利用亲密性，并结合明确的右对齐或左对齐，你会惊异于设计的改观。</p>
</li>
<li><p>我并不是建议你绝对不要居中！只是要留意这种居中对齐的效果，这真的是你想要表达的效果吗？当然，有时候确实如此；例如，大多数婚礼都很庄重、很正式，所以，如果你想用居中方式设计你的结婚喜帖，完全可以在营造喜庆的同时有意这么做。</p>
</li>
<li><p>在得到更多培训之前，一定要坚持一个原则：页面上只使用一种文本对齐：所有文本都左对齐，或右对齐，或者全部居中。</p>
</li>
<li><p>有时，你可能喜欢在同一个页面上同时使用右对齐和左对齐文本，不过一定要确保让这些文本以某种方式对齐！</p>
</li>
<li><p>尽管这些孤立元素在页面上的物理位置可能并不靠近，但是通过适当放置，可以让它们看上去是有联系而且相关的，并且与其他信息统一。</p>
</li>
<li><p>可以把重复认为是“一致性”。</p>
</li>
<li><p>不过重复还不只是自然的一致，这是一种统一设计各个部分的有意识的行为。</p>
</li>
<li><p>如果一个出版物有非常好的一致性，则可以放入一些与众不同的元素，使读者真正注意到你希望他们关注的内容。</p>
</li>
<li><p>不要把重复用得太滥，而应当尽量“采用多样性实现统一”。也就是说，如果一个重复元素很明确（如一个圆），那么可以采用多种不同方式重复这个圆，而不是简单地重复同一个圆。</p>
<ul>
<li>感觉重复性原则很难应用好</li>
</ul>
</li>
<li><p>重复还会为你的作品带来一种专业性和权威性。它会使读者感觉有人在负责，因为重复显然是一种经过深思熟虑的设计决策。</p>
</li>
<li><p>重复并不表示必须重复完全相同的东西。</p>
</li>
<li><p>重复可以认为是保持一致性，而且我相信你早已经这样做过。现在，需要把现有的一致性更向前推进一步。</p>
</li>
<li><p>要避免太多地重复一个元素，重复太多会让人讨厌。要注意对比的价值</p>
</li>
<li><p>要增加有意思的对比，最容易的方法就是实现字体对比（这也是本书第二部分的重点）。不过不要忘记，还可以利用线、颜色、元素之间的间隔、材质等形成对比。</p>
</li>
<li><p>在设计原则中，对比最有意思，同时效果也最为显著！只需几个小小的改动，就能把一个普普通通的设计变成一个精美的设计。</p>
</li>
<li><p>希望你已经看出，对比对于设计作品来说是何等重要，另外也应该能看出增加对比实际上是何等容易。</p>
</li>
<li><p>对比的根本目的有两方面，这两个方面相辅相成，无法分开。一个目的是增强页面的效果，如果一个页面看起来很有意思，往往更有可读性。另一个目的是有助于信息的组织。读者应当能立即了解信息以何种方式组织，以及从一项到另一项的逻辑流程。对比元素不能让读者混淆，也不能错误地强调重点（即本不该是重点的元素）。</p>
</li>
<li><p>重要的是：对比一定要强烈。</p>
</li>
</ul>
]]></content:encoded>
      <comments>http://fancymax.github.io/2017/04/06/book201704/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[订票助手12306ForMacV1.6更新]]></title>
      <link>http://fancymax.github.io/2017/03/17/12306ForMacV16/</link>
      <guid>http://fancymax.github.io/2017/03/17/12306ForMacV16/</guid>
      <pubDate>Fri, 17 Mar 2017 14:39:55 GMT</pubDate>
      <description>
      <![CDATA[<h2 id="支持多日期串行查询">支持多日期串行查询</h2><p><img src="https://ooo.0o0.ooo/2017/03/17/58cbec3120077.png" alt="test"></p>
<h2 id="查到票后Reminder提醒">查到票后]]>
      </description>
      <content:encoded><![CDATA[<h2 id="支持多日期串行查询">支持多日期串行查询</h2><p><img src="https://ooo.0o0.ooo/2017/03/17/58cbec3120077.png" alt="test"></p>
<h2 id="查到票后Reminder提醒">查到票后Reminder提醒</h2><p>若查到票时不在电脑旁边，则会通过iPhone提醒</p>
<p><img src="https://ooo.0o0.ooo/2017/03/17/58cbf3af6f4c4.png" alt="test"></p>
<p>或者Apple Watch提醒</p>
<p><img src="https://ooo.0o0.ooo/2017/03/17/58cbedd88996b.png" alt="test"></p>
<h2 id="改进车次筛选功能">改进车次筛选功能</h2><p><img src="https://ooo.0o0.ooo/2017/03/17/58cbef7d1c82f.png" alt="test"></p>
<h2 id="日历显示更多节假日">日历显示更多节假日</h2><p><img src="https://ooo.0o0.ooo/2017/03/17/58cbf00a000c7.png" alt="test"></p>
<h2 id="登录界面快捷键">登录界面快捷键</h2><p>右手用鼠标或触控板选择验证码，左手按Space键确定，非常方便<br><img src="https://ooo.0o0.ooo/2017/03/17/58cbf42df0f20.png" alt="test"></p>
<h2 id="节假日预售期提醒">节假日预售期提醒</h2><p>可以一键生成 之后一年的节假日 预售期的日历提醒，提前做好买票计划。<br><img src="https://ooo.0o0.ooo/2017/03/17/58cbf165b3d06.png" alt="test"></p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2017/03/17/12306ForMacV16/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[2016到2017]]></title>
      <link>http://fancymax.github.io/2017/01/04/2016end/</link>
      <guid>http://fancymax.github.io/2017/01/04/2016end/</guid>
      <pubDate>Wed, 04 Jan 2017 13:38:04 GMT</pubDate>
      <description>
      <![CDATA[<p>2016最后一天: 早起爬梧桐山，又从梧桐山门口骑车回家。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>2016最后一天: 早起爬梧桐山，又从梧桐山门口骑车回家。<br><a id="more"></a><br>在家旁边发现一个箱子里有只被遗弃的小奶猫，在可怜的喵叫~<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017010474719cat1.jpeg" alt="2017010474719cat1.jpeg"></p>
<p>和婷妹子商量纠结了很久，最后决定挽救这个可怜又可爱的小生命。<br>马上抱去楼下的宠物医院做检查和护理。小奶猫估约五天大，眼睛还没睁开。宠物医生说没有猫妈的小猫很难养活。不过我和婷妹子都没有被吓倒，不可能再把小猫放回路边，于是我们当起了临时猫妈，买了猫奶嘴，针管，猫奶粉。开始了每两个小时给猫喂奶，把屎把尿的艰难过程。一开始两人都搞不过来。一弄一个小时就过去。半夜弄完之后就没睡着。</p>
<p>2017第一天婷妹子加班去了，我居然能独自一人喂了小猫一天。局外人绝对无法理解我见证小猫能拉出屎时有多高兴，感觉这样它又增加了几分存活的概率。<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017010450559cat2.jpeg" alt="2017010450559cat2.jpeg"></p>
<p>傍晚时分婷妹子说找到了爱猫人士愿意收留小猫。虽然自己挺不舍得，但也没有条件继续24小时照顾小猫。于是最后一次给小猫喂完奶做好保暖措施，然后送走了，愿这只可爱的小奶猫可以健康的活下来。<br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/2017010477858cat3.jpeg" alt="2017010477858cat3.jpeg"><br><img src="http://7xqmjb.com1.z0.glb.clouddn.com/201701045192cat4.jpeg" alt="201701045192cat4.jpeg"></p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2017/01/04/2016end/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[老友记]]></title>
      <link>http://fancymax.github.io/2016/03/24/friends/</link>
      <guid>http://fancymax.github.io/2016/03/24/friends/</guid>
      <pubDate>Thu, 24 Mar 2016 12:05:10 GMT</pubDate>
      <description>
      <![CDATA[<p>老友记 又称 六人行，英译称“friend”是一部由David Crane与Marta Kauffman共同创作的美国情景喜剧。该剧于1994年9月22日在NBC播出，于2004年5月6日结束，共播出十季，剧情主要围绕着一众好友在纽约曼哈顿的生活展开。]]>
      
      </description>
      <content:encoded><![CDATA[<p>老友记 又称 六人行，英译称“friend”是一部由David Crane与Marta Kauffman共同创作的美国情景喜剧。该剧于1994年9月22日在NBC播出，于2004年5月6日结束，共播出十季，剧情主要围绕着一众好友在纽约曼哈顿的生活展开。<a id="more"></a></p>
<blockquote>
<p>此剧由Bright/Kauffman/Crane Productions联合华纳兄弟电视公司制作。《老友记》最初的三位执行制片人分别为Kevin S. Bright、Marta Kauffman以及David Crane，而在之后的季度中亦陆续加入多位执行制片人。该剧在超过一百个国家播放，而且后续的重播依然有着良好的收视。据估计在美国有5110万人观看了该剧的大结局。</p>
</blockquote>
<p>最早知道老友记应该是在高中的时候吧，那时候流行看剧学英语，所以知道了这部剧之后就特意买光盘回来看，抱着这样功利的态度努力的看，可惜直到高中毕业都没看完，也没领会到剧中的搞笑桥段。</p>
<p>之后上大学的时候，某次机缘之下下载到了老友记的全部资源，然后又想起我看剧学英语的未竟事宜，不禁还想尝试一下，就偶尔翻出来看看，发现这剧还真是有点意思。于是每当我烦闷的时候，都会拿几集老友记来看看逗自己开心一下，发现还真是超级有效果。大学四年转瞬而过，而我还真的把十季的老友记完整的看下来一遍。里面好多搞笑的桥段、令人感动的情节方佛给我的大学时光抹上一层色彩，让人回忆起来更有味道。</p>
<p>工作后在上午下班 到 下午上班之间的这段时间比较无聊，于是我又捡起老友记来看，老友记一集不到半小时，正好从12:10看到12:40，然后睡半小时午觉。虽然是重看老友记，但是我一点也不觉得无聊，搞笑的桥段还是会让我开怀大笑，好多次都差点吵到旁边的同事。几年下来，我居然又把老友记完整的看了两次，连我自己到惊到了，😄</p>
<p>说了这么多，一方面是缅怀一下自己的看剧时光，另一方面是想把它推荐给大家。😜，如果你既想排解一下烦闷的心情，又想学学英语，这部经典的老友记不妨一看。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2016/03/24/friends/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[又是一年深圳百公里]]></title>
      <link>http://fancymax.github.io/2016/03/03/100miles/</link>
      <guid>http://fancymax.github.io/2016/03/03/100miles/</guid>
      <pubDate>Thu, 03 Mar 2016 11:12:11 GMT</pubDate>
      <description>
      <![CDATA[<p>深圳每年这个时候都会举办百公里徒步]]>
      
      </description>
      <content:encoded><![CDATA[<p>深圳每年这个时候都会举办百公里徒步<a id="more"></a>，这种类型的徒步比马拉松难度小很多，但也颇具挑战性。你想象一下从第一天晚上六点开始走一直走到第二天晚上六点，全程24小时只能进行短暂的休息，没有一定的毅力和体力是走不完的。</p>
<p>正是由于参加的门槛低，但是完成全程又极具有挑战性，所以每年百公里都吸引的大量的“徒步爱好者”参加，甚至听说有人专程从厦门赶来参加，足以想见它的火爆程度。俗语有云“没有逛过东门街，就相当于没有来过深圳”，我再加一句“没有走过百公里，就相当于没有深入了解过深圳”。</p>
<p>都说深圳是个年轻的城市，由百公里徒步可见一斑，我见到过年轻夫妇推着婴儿车来参加的，也见到过50多岁的大叔脚绑沙袋负重参加徒步的。当然大部分人都是来凑凑热闹的，只有很少的一部分人能走完全程。毕竟连续走24小时也不是闹着玩，如果不是追求自虐或者有什么特殊的信念很难坚持下来。所以走完全程然后表白 或者 求婚算是一个good idea，单身的同志不妨一试。</p>
<p>我也参加了好几次百公里活动了，在2014年的那次有幸走完了全程。然后一开始我是很酱油的，想的就是走完10公里回去睡觉，所以别人都是背包＋装备，而我两手空空。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl1.jpg" alt="demo"></p>
<p>当我们到第一个十公里的时候，一个同行的小伙伴就要撤了回家睡觉，而我却突然想继续走下去，想任性一把，－－！本来第二天要加班的。于是我继承了她的全部装备(包括充电宝和和各种吃的)。</p>
<p>走到第二个签到点还发现有人求婚。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl2.jpg" alt="demo"><br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl5.jpg" alt="demo"></p>
<p>第二个签到点后已经凌晨1点了，后面基本上都是一个人在走，听着ipod，漫漫长夜也别有一番趣味。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl4.jpg" alt="demo"><br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl3.jpg" alt="demo"></p>
<p>等到了第三个签到点，基本上天快亮了，到了梧桐山门口，这时候其实状态还是不错的。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl6.jpg" alt="demo"></p>
<p>之后就是非常艰难的上山之旅，和我一起来的小伙伴已经全部溃败，只剩下我一个人，十分艰难的走到了大梅沙。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl7.jpg" alt=""></p>
<p>之后的路程基本上就是在自虐了，而我只能尽量减少休息的时间，基本就一直在走，累了就喝红牛，因为脚已经非常疼了，走的特别慢，一路上老是被别人超过，那些走的特别轻快的基本上都是从大梅沙这个半程开始走的。另外这时候太阳是非常晒的，如果没有做好防护措施的话，第二天全部要晒脱皮，所以我半路买了头巾和帽子把自己包的紧紧的。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl9.jpg" alt=""><br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl10.jpg" alt=""></p>
<p>也不知道哪来的毅力，我竟真的走完了全程。老实说今年我是没有信心可以走完的。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl12.jpg" alt=""><br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl11.jpg" alt=""></p>
<p>Boss在朋友圈看到我走完全程的照片还问要不要给我放三天假。当然我第二天还是照常去上班了，只是走路有点瘸，然后惊喜的发现当天的报纸头条是百公里。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/bgl13.jpg" alt=""></p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2016/03/03/100miles/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[卖书]]></title>
      <link>http://fancymax.github.io/2016/02/18/sellbook/</link>
      <guid>http://fancymax.github.io/2016/02/18/sellbook/</guid>
      <pubDate>Thu, 18 Feb 2016 06:20:53 GMT</pubDate>
      <description>
      <![CDATA[<p>其实很早就有卖书的想法，工作这两年买的纸质书已经已经堆满了我的书架，有些甚至都堆放到了同事的书架上。]]>
      
      </description>
      <content:encoded><![CDATA[<p>其实很早就有卖书的想法，工作这两年买的纸质书已经已经堆满了我的书架，有些甚至都堆放到了同事的书架上。<a id="more"></a>再加上我这人有点强迫症，那些不再使用的东西，我都不希望它出现在我的眼前，否则会浑身难受。</p>
<p>有些书我已经完整的看过一遍，感觉未来不可能再看第二遍了。还有一些书我买回来看了一眼就没再看过第二眼，我感觉未来也不可能再去拾起来看。这些书我都想统统清理掉，直接扔掉肯定是不舍得的，直接送给朋友吧他们可能未必需要，反而弄得自己费力不讨好。</p>
<p>之前看到有些技术大牛在自己的博客上卖书，感觉是一个不错的方式，一方面有人愿意花钱买的书证明了你的书对他是有价值的，另一方面可以满足我的强迫症－－! 把这些看完的书消灭掉；当然啦，还可以赚一点零花钱。</p>
<p>想法和方法都有了，但真正实施起来发现相当困难；自己的博客基本没啥访问量，要想靠它卖出去不知道要等到猴年马月了；另外尝试了一些地方也都以失败告终，比如豆瓣二手书市场、淘宝的闲鱼、孔夫子二手书，究其原因我不就是卖几本书吗？还要折腾淘宝的卖家账号太费劲了，另外我也没兴趣去做包装，快递之类的事情，我的理想就是同城现场交易，大家一手交钱，一手交书，还能坐下来聊聊天；还有就是这些服务定位的是更为广义的二手市场，而我手上就是一些IT和人文之类的书，很难快速匹配到需要它的人。</p>
<p>转折点在最近我喜欢上的一个叫V2ex的创意社区网站，上面聚集了很多程序员、设计师、创意者。</p>
<p>V2ex上有一个二手交易的节点，同时上面又聚集了大量的程序员，所以我发了一个卖书的帖子没多久，就吸引到了目标读者。不到一天就敲定了第一笔交易（就在发帖的第二天，也就是今晚）：木心的两册《文学回忆录》 ＋ 《程序员的数学》，我们还约定随便吃个饭，聊聊天，这效果真是好的不要不要的。</p>
<p>马上就要成功把书卖掉了，但是心里却有点的不舍。尤其这两册《文学回忆录》，它陪我度过了一些美好的时光，时间拉回到2013年的时候，我经常下班的时候拿着这两本书找个安静的角落细细咀嚼，虽然我的文学素养不太好，但还是看的很有意思，摘录一段：</p>
<blockquote>
<p>   乔治.戈登.拜伦(George Gordon Byron, 1788-1824)。得年三十六岁，标准天才型人物的死亡。生于伦敦。家父是家事不管的花花公子。母亲脾气坏。拜伦从小不相让，吵。拜伦是个穷的贵族。妈妈骂他是“拐子”，他说：说这话的还是个人吗？</p>
<p>   不幸的童年，使人性格尖锐。</p>
<p>   上大学后是个捣蛋鬼，受罚。向往异国情调—这是十九世纪的特征。二十一岁游西班牙、希腊、土耳其，边游边写诗，就是《哈罗德游记》，哈罗德是诗中的主角名字。诗寄回英国，头两卷发表后，拜伦说：“我一早醒来，一夜成名，成为诗台上的拿破仑。”</p>
<p>   这就是拜伦：说得出，做得到；做得到，说得出。</p>
<p>   1815年结婚，1816年离婚。就是这样。这种婚姻，就是拜伦风格。当时英国多么保守，舆论大哗。他一怒之下，离国出走，说永远不回来了。</p>
<p>   拜伦的脾气。</p>
<p>   他是贵族、诗人、美男子、英雄，是多重性质的象征。我小时候一看这名字，还没读作品，就受不了了。再看画像，更崇拜。宝玉见黛玉，说这位妹妹好像哪儿见过。我见拜伦，这位哥哥好像哪儿见过。精神血统就是这样。席勒，我总隔一层；雪莱，我视为邻家男孩；拜伦，我称为兄弟。</p>
<p>   人类文化至今，最强音是拜伦：反对权威，崇尚自由，绝对个人自由。</p>
<p>   真挚磅礴的热情，独立不羁的精神，是我对拜伦最心仪的。自古以来，每个时代都以这样的性格最为可贵。<br>   英国文学，莎士比亚之后，公推拜伦。</p>
</blockquote>
<p>当时看了对拜伦的评价之后也是很激动，还特意去图书馆借了拜伦的书来看。转眼两年过去了，当初立下目标要把文学回忆录上列出的每本经典书籍都看一遍终究是没能做到，不过《文学回忆录》我是完整的看了一遍下来的，也算一段珍贵的回忆吧。现在已经答应别人要卖了，也不好反悔，假如以后我还想看就去买一份Kindle版的做珍藏好了。</p>
<p>书目如下：</p>
<ul>
<li>人文类<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/book5.pic.jpg" alt="book"></li>
</ul>
<ul>
<li><p>C&amp;C++<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/book4.pic.jpg" alt="book"></p>
</li>
<li><p>iOS相关<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/book1.pic.jpg" alt="book"></p>
</li>
</ul>
<ul>
<li><p>C#相关<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/book3.pic.jpg" alt="book"></p>
</li>
<li><p>其他<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/book2.pic.jpg" alt="book"><br><img src="http://7xpbra.com1.z0.glb.clouddn.com/book6.pic.jpg" alt="book">  </p>
</li>
</ul>
]]></content:encoded>
      <comments>http://fancymax.github.io/2016/02/18/sellbook/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[智能车]]></title>
      <link>http://fancymax.github.io/2016/02/11/LittleCar/</link>
      <guid>http://fancymax.github.io/2016/02/11/LittleCar/</guid>
      <pubDate>Thu, 11 Feb 2016 05:48:40 GMT</pubDate>
      <description>
      <![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/154949001" frameborder="0" allowfullscreen></iframe></div>]]>
      
      </description>
      <content:encoded><![CDATA[<div class="video-container"><iframe src="//player.vimeo.com/video/154949001" frameborder="0" allowfullscreen></iframe></div>
<a id="more"></a>
<p>今天偶然翻出大学时做智能车的一个视频，这是当时校内比赛现场，我负责车子的软件部分。</p>
<p>车子没拿到什么名次，但我们也付出了巨大努力。我的自学能力大概就是在那个时候锻炼的。也是那个时候开始喜欢上做产品（软件）的那种感觉。正因为此我是系里仅有的几个没有选择进到体制内而是进软件公司的人。现在工作五年了，虽然当初的理想还没有实现，但至少毕业的选择让我保有这个可能性。</p>
<p>所以我打心底里很感谢这个智能车项目，它让我体验到从无到有做出一个产品的乐趣，它改变了我的职业生涯和人生轨迹。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2016/02/11/LittleCar/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[iPhone维修记]]></title>
      <link>http://fancymax.github.io/2016/01/24/iPhone/</link>
      <guid>http://fancymax.github.io/2016/01/24/iPhone/</guid>
      <pubDate>Sun, 24 Jan 2016 02:20:05 GMT</pubDate>
      <description>
      <![CDATA[<p>这几周耗费大量时间，精力和金钱的修手机心酸史，有必要总结一下(￣▽￣)<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>这几周耗费大量时间，精力和金钱的修手机心酸史，有必要总结一下(￣▽￣)<br><a id="more"></a></p>
<h1 id="维修地点">维修地点</h1><p>如果是在HK苹果直营店买的听说可以在内地Apple售后维修(^没有实践过^)。<br>其次可以在HK的几大直营店维修。<br>如果是在其他地方购买，不能在Genius Bar维修。需要看当时购买的单据上描述的维修地址。<br>丰泽的最近维修地址是九龙旺角西洋菜南街2A至2H号银城广场12楼01-03室。地方蛮好找的，就是地铁到旺角东站，走过波鞋街和女人街，在旺角地铁站出口，电器一条街的尽头，百脑汇和SaSa的楼上，如下图(今天在没网没地图听不懂白话讲不出英语的前提下找到这个地方实属不易)。这些地方只有周一到周六上班，上周日去了，白跑一趟-_-#<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/hk_1.jpg" alt="2"></p>
<h1 id="预约方式">预约方式</h1><p>如果在直营店购买的手机可以预约香港Apple官网的Genius Bar，预约需要香港手机，一个手机号一周只能收到三次验证码，需要先输入验证码才能看到还能不能预约。<br>听闻早上8点半放号，害得我借了手机卡，早上起来蹲点，比自己抢火车票还积极，然并卵，这个号比火车票还难抢，最好花80大洋，去淘宝买了个号，感谢万能的淘宝。<br>听闻可以直接去直营店排队维修，实际貌似是能帮你检查，如果真的要维修，还的预约。<br>非直营店手机貌似也可以网上预约，或者去Genius Bar让他们给你开证明直接去维修。<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/hk_2.jpg" alt="1"></p>
<h1 id="维修结果">维修结果</h1><p>个人感觉苹果维修很容易换机，这次维修手机已经交给她们，得等12个工作日出结果。</p>
<h1 id="维修准备">维修准备</h1><p>直营购买香港维修需要手机，不需要包装和配件，就算是换机也只是机子。<br>非直营购买手机需要购买时的收据。</p>
<h1 id="温馨提示">温馨提示</h1><p>过年过关人太多，大叔大妈行李箱太挤，小心踩踏事件。<br>「最最重要，珍爱生命，远离Apple」。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2016/01/24/iPhone/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[OS X编程资料总结]]></title>
      <link>http://fancymax.github.io/2015/12/31/OS-X-learning/</link>
      <guid>http://fancymax.github.io/2015/12/31/OS-X-learning/</guid>
      <pubDate>Thu, 31 Dec 2015 13:10:45 GMT</pubDate>
      <description>
      <![CDATA[<p>iOS的开发特别火爆，OS X的却很冷淡。新手常常觉得OS X的开发难以入门，原因是资料特别少，包括当初的我在内。所以我整理了一些入门必备的工具 或 资源，希望对大家有所帮助。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>iOS的开发特别火爆，OS X的却很冷淡。新手常常觉得OS X的开发难以入门，原因是资料特别少，包括当初的我在内。所以我整理了一些入门必备的工具 或 资源，希望对大家有所帮助。<br><a id="more"></a></p>
<ul>
<li><p><a href="https://kapeli.com/dash" target="_blank" rel="external">Dash for OS X</a></p>
</li>
<li><p>科学上网:<a href="https://itxs.li" target="_blank" rel="external">土行孙</a>或者<a href="https://getlantern.org" target="_blank" rel="external">lantern</a></p>
</li>
<li><p>OS X Human Interface Guidelines</p>
</li>
<li><p>The Swift Programming</p>
</li>
<li><p><a href="http://www.amazon.cn/Swifter-100个Swift-2-开发必备Tip-王巍/dp/B019CRN7TW/ref=sr_1_2?ie=UTF8&amp;qid=1451567750&amp;sr=8-2&amp;keywords=Swifter" target="_blank" rel="external">Swifter 100 tips</a></p>
</li>
<li><p><a href="http://www.amazon.cn/Cocoa-Programming-for-OS-X-The-Big-Nerd-Ranch-Guide-Hillegass-Aaron/dp/0134076958/ref=sr_1_4?ie=UTF8&amp;qid=1451567670&amp;sr=8-4&amp;keywords=Cocoa" target="_blank" rel="external">Cocoa Programming for Mac OS X(5th)</a>里面用的是Swift讲解，介绍的例子通俗易懂，全书的例子做一遍下来，开发简单的OS X程序不成问题。</p>
</li>
<li><p>Advanced Mac OS X Programming(2011)</p>
</li>
<li><p>Cocoa® Programming Developer’s Handbook(2010)</p>
</li>
<li><p>Cocoa Design Patterns</p>
</li>
<li><p>AppleScript For Absolute Starters</p>
</li>
<li><p>Effective Objective-C 2.0_ 52 S - Galloway, Matt</p>
</li>
<li><p>Pro Multithreading and Memory Management for iOS and OS X with ARC, Grand Central Dispatch, and Blocks</p>
</li>
<li><p><a href="https://www.cocoacontrols.com" target="_blank" rel="external">Cocoacontrols</a>，网站收集了各种iOS和OS X的自定义控件，很有参考意义。</p>
</li>
</ul>
<p>最后当然还可以查各种Apple的文档。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2015/12/31/OS-X-learning/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[我的2015]]></title>
      <link>http://fancymax.github.io/2015/12/29/my2015/</link>
      <guid>http://fancymax.github.io/2015/12/29/my2015/</guid>
      <pubDate>Tue, 29 Dec 2015 12:30:05 GMT</pubDate>
      <description>
      <![CDATA[<p>年末最适合像这样，拿杯最喜欢的饮料，调暗灯光，舒舒服服的靠在沙发上，想一想这过去的十二月你都做了什么。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>年末最适合像这样，拿杯最喜欢的饮料，调暗灯光，舒舒服服的靠在沙发上，想一想这过去的十二月你都做了什么。<br><a id="more"></a><br>记忆中的关键词有：欢乐谷跨年、陈奕迅演唱会、香港代购、去女朋友家过年、穿越东西冲、去香港的南丫岛、五一长假、买房装修搬家、玩PS4、开发12306ForMac。</p>
<p>总的感觉自己这一年过的还是比较滋润的。<br>尤其是前半年玩的比较多，印象最深的就是五一请了9天假和女友去了一趟成都和重庆玩了九寨沟、峨眉山等地。虽然只有短短的9天，但是感觉好像放了长长的一个寒假一样，特别的放松，同时也加深了女友的感情。</p>
<p>后半年相对就平淡和辛苦一些，主要原因就是折腾着买房了，同时还有一堆装修搬家的事情，越是在这种时候越是能体现出有女朋友的好处了。<br>在我们马上要搬入新家的前一个月，前房东通知我必须要搬走，而且没得商量，不得已我们只能再找个房子住一个月，当时真是别提多闹心了。不过还好有个人可以一起承担，郁闷减半。</p>
<p>经过两个多月的努力新房总算搞定，顺利入住。现在再去想想以前那些租房住的痛苦回忆，恍若隔世一般。</p>
<p>另外，今年开始计划着做一些个人作品，比如12306ForMac，它是一款针对Mac的火车票抢票客户端，目前完成了50%左右。<br>同时为了方便后期的产品的推广和维护，我开通了fancywt.cn这个博客，当然我也会把平常的一些想法和感悟总结在这里。</p>
<p>2015是个充满回忆的一年，期待我的2016更加精彩。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2015/12/29/my2015/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[12306forMac 开发日记]]></title>
      <link>http://fancymax.github.io/2015/12/20/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-%E4%B8%8A/</link>
      <guid>http://fancymax.github.io/2015/12/20/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-%E4%B8%8A/</guid>
      <pubDate>Sun, 20 Dec 2015 02:37:22 GMT</pubDate>
      <description>
      <![CDATA[<p>先谈谈做 Mac 版的初衷(市面上已经有那么多抢票软件了，为什么还要重新发明轮子？)</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>先谈谈做 Mac 版的初衷(市面上已经有那么多抢票软件了，为什么还要重新发明轮子？)</p>
<a id="more"></a>
<p>最早是因为女朋友，她家是湖南的。从深圳到湖南那票叫一个难买。<br>去年别人介绍 买了一款心蓝的订票软件（没有Mac版,装在我的虚拟机上,刷票刷了两个月总算买到回湖南的两张高铁票。 </p>
<p>于是我就想弄一个Mac版的订票助手,不用开虚拟机,在后台以最小的消耗帮我刷票。</p>
<p>抢票的话我感觉基本看运气和软件关系不是太大，用手机抢完全 OK ，个人认为 Mac 版的功能应该偏重于检票。实时监控60(现在是30)天，基本上 90%可以买到票。</p>
<p>当然刷票的过程比较累心，因此订票助手要尽量做到不影响大家正常工作，默默的在后台监控余票，等到有票的时候再通知。</p>
<h1 id="开发心得">开发心得</h1><p>说做就做，我原来是做WPF的，对Cocoa开发并不熟，不过客户端开发大同小异，通过<a href="http://fancywt.cn/2015/12/31/OS-X-learning/" target="_blank" rel="external">Cocoa的入门书籍</a>看上一周基本可以上手。</p>
<p>另外由于我用的是12306的网页接口，所以一个趁手的抓包工具就尤为重要了，Mac平台最靠谱的就是Charles。</p>
<p>最早是15年7月就开始写了，两个月的时间(每天花了半小时)基本实现了订票的功能。有几个痛苦的地方：</p>
<ol>
<li>12306的接口，老是变，各种坑。</li>
<li>Cocoa，写界面有点麻烦, 和WPF比差的有点多。</li>
<li>界面交互，一开始没重视，导致想一步做一步，来回返工。</li>
</ol>
<p>开发的过程遇到很多挫折,很多时候都想放弃了，但是自己拉的屎，含着泪也要擦干净，一开始的失误只能用时间来弥补。下面是界面截图，大家可以看出一点一点的进步。</p>
<ol>
<li><p>第一版<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/12306ForMac-1st.png" alt="demo"></p>
</li>
<li><p>第二版<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/12306ForMac-2nd.png" alt="demo"></p>
</li>
<li><p>第三版<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/12306ForMac.png" alt="demo"></p>
</li>
<li><p>第四版<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/201612197793712306_final.png" alt="201612197793712306_final.png"><br>从第一版到第四版经过了一年的时间，因为第一次写mac上程序，所以一直在一个摸索的过程，不过慢慢的也找到点规律：</p>
<ol>
<li>界面配色种类要少，有个主次界面配色，对比要鲜明。</li>
<li>由于精力有限，界面只能往简洁大方方向发展。</li>
</ol>
</li>
</ol>
<h1 id="后续想法">后续想法</h1><p>后面会继续完善这个程序，并且一直开源、免费。另外考虑做一个内购的方式的捐赠，大家如果觉得好可以付费支持我。</p>
<p>软件功能上还是侧重于 订票 和 检票，抢票还是算了，折腾不过。</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2015/12/20/%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B0-%E4%B8%8A/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[敏捷开发培训总结]]></title>
      <link>http://fancymax.github.io/2014/05/22/summaryOnSoftDevelopment/</link>
      <guid>http://fancymax.github.io/2014/05/22/summaryOnSoftDevelopment/</guid>
      <pubDate>Thu, 22 May 2014 06:08:18 GMT</pubDate>
      <description>
      <![CDATA[<p>前段时间参加了两天敏捷开发管理培训，收获挺大，在这里做一下总结。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>前段时间参加了两天敏捷开发管理培训，收获挺大，在这里做一下总结。</p>
<a id="more"></a>
<h2 id="理解敏捷">理解敏捷</h2><p>整个培训过程中一直穿插着敏捷软件开发的原则进行讲解，这里摘录给我感触最深的几个：</p>
<ul>
<li>我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意，经常地交付可工作的软件，相隔几星期或一两个月，倾向于较短的周期。</li>
<li>业务人员和开发人员必须相互合作，项目中的每一天都不例外。</li>
<li>团队定期反思如何能提高成效，并依此调整自身的举止表现。</li>
<li>激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。</li>
</ul>
<p>敏捷流派主要有两个：Scrum 和 极限编程。Scrum侧重项目协作流程，极限编程侧重提高编程效率的技术实践。两者应该相辅相成。这里着重讲讲Scrum。</p>
<h2 id="团队与角色">团队与角色</h2><p>Scrum中有Product Owner、Team、Scrum Master三类角色。一个好的Scrum团队以下特点：</p>
<ul>
<li>通常5~9人；</li>
<li>跨职能，跨模块人员构成；</li>
<li>成员应全职投入；</li>
<li>团队自组织管理；</li>
<li>迭代内保持团队成员稳定。</li>
</ul>
<p>做好一个Product Owner要点如下：</p>
<ul>
<li>定义产品功能；</li>
<li>定义产品发布的日期和功能；</li>
<li>对产品的投入产出比负责；</li>
<li>根据市场情况对需求排列优先级；</li>
<li>如果需要，在每个迭代合理调整产品特性及其优先级；</li>
<li>介绍或拒绝开发团队的工作成果。</li>
</ul>
<p>Scrum Master要引导团队自己去找答案，而不是做一个发号司令的人，做好一个Scrum Master要点如下：</p>
<ul>
<li>Scrum正常运作的守护者；</li>
<li>激发团队创造力；</li>
<li>改善开发团队的外部环境；</li>
<li>辅导团队提升运作效率；</li>
<li>排除团队遇到的困难；</li>
<li>保持团队紧密合作；</li>
</ul>
<p>Team就是团队中的开发、测试或ui设计人员。</p>
<h2 id="需求管理">需求管理</h2><p>Scrum通过编写用户故事来管理需求，好的用户故事的原则如下：</p>
<ul>
<li>Independent独立的；</li>
<li>Negotiable：可讨论的；</li>
<li>Valuable：对用户或客户有价值的；</li>
<li>Estimatable：可估计的；</li>
<li>Small：小的；</li>
<li>Testable：可测试的。</li>
</ul>
<p>之后要进行工作量估算，Product Owner(业务人员)必须在场梳理需求，每个项目成员针对用户故事的疑问向Product Owner提问，所有人弄清楚需求后开始。</p>
<p>大家先找一个参照需求，确定它的工作量，然后其他的需求就按照这个参照需求来估计，这种相对估计法确保每个人估计出来的工作量是一致的。</p>
<p>使用扑克牌，大家同时给出需求的估计值（而不是轮流进行），估值最高和最低的必须分别给出原因，这样做的好处让大家都独立思考。通过多轮估值让所有人了解需求，并估算出一个较为合理的工作量。</p>
<h2 id="Scrum中的各项活动">Scrum中的各项活动</h2><p>简单来说，划分如下</p>
<p>项目计划|<br>Sprint0|<br>Sprint1|<br>Sprint2|<br>Sprint3|<br>项目总结|</p>
<p>按一个迭代周期来说，主要划分如下：迭代计划和评审一般要占用两个小时，而站立会议一般15分钟。</p>
<p>迭代计划1|<br>迭代计划2|<br>站立会议|<br>…|<br>站立会议|<br>迭代评审|<br>迭代回顾|</p>
<p>Spint0要做一些准备活动，如高层的业务流程图、初始的用户故事列表、测试策略、发布计划、团队建设、技术架构的选择、设计UI的风格等。</p>
<h3 id="站立会议">站立会议</h3><p>晨会的要点：</p>
<ul>
<li>轮流发言，持Token者才可以发言；</li>
<li>不讨论深入细节；</li>
<li>不是对领导汇报，让团队中每个人都了解你的发言；</li>
<li>不能单独讨论，自发的有序的进行发言；</li>
<li>时间在15分钟以内。</li>
</ul>
<p>站立晨会的三个经典问题：昨天我完成了哪些工作；明天我打算做什么；完成我的目标是否存在什么障碍。<br>站立晨会的目的不是为了让大家都回答那三个问题，而是让团队围绕这三个问题，制定当天的工作计划并暴露问题。</p>
<h3 id="迭代验收和回顾">迭代验收和回顾</h3><p>迭代验收会议，通过演示可工作的软件检查需求是否满足客户要求；迭代验收的好处：</p>
<ul>
<li>通过演示可工作的软件来确认项目的进度，具有真实性；</li>
<li>能尽早获得用户对产品的反馈，使产品更贴近客户需求。</li>
<li>收集反馈。</li>
</ul>
<p>迭代回顾会议，目的是分享好的经验和发现改进点，促进团队不断进步，迭代回顾的好处：</p>
<ul>
<li>激励团队成员；</li>
<li>帮助团队挖掘优秀经验并继承；</li>
<li>避免团队犯重复的错误；</li>
<li>营造团队自主改进的氛围。</li>
</ul>
<h2 id="利用敏捷改进现有工作">利用敏捷改进现有工作</h2><p>即使不使用敏捷方式开发，也可以利用它的一些好的想法和实践可以用来提升目前的工作效率。</p>
<ul>
<li>比如敏捷开发中如何调动团队积极性，让每个人看到的是团队目标，而不是个人目标。</li>
<li>比如经常地交付可工作的软件：以此提高软件开发的质量和可交付性。</li>
<li>比如借鉴敏捷中设定Sprint(冲刺)的开发过程，调动开发人员的积极性以及明确每个开发阶段的目的性。</li>
</ul>
<h2 id="其他问题">其他问题</h2><ul>
<li>需求文档 或者 使用说明文档 写了100多页，但是写完之后基本没人看，这样的问题应该很普遍，该如何解决？<br>把Word文档迁移到Wiki上，大文档切细分成一个个独立的Wiki页面，Wiki可以统计页面的访问次数，有了足够的数据支撑之后就可以把访问次数少的页面去掉，以此来精简文档，这样留下来的文档内容就是真正有用的。</li>
</ul>
<ul>
<li>业务部门的需求太多而且每个都非常紧急，怎么处理？<br>业务部门拉一个人对需求按价值进行排序；需求收集例行化，主动收集，需求有一定的清晰度；回顾哪些需求不重要，做为武器。</li>
</ul>
]]></content:encoded>
      <comments>http://fancymax.github.io/2014/05/22/summaryOnSoftDevelopment/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[浅谈研发项目经理]]></title>
      <link>http://fancymax.github.io/2014/04/20/talkAboutPM/</link>
      <guid>http://fancymax.github.io/2014/04/20/talkAboutPM/</guid>
      <pubDate>Sun, 20 Apr 2014 06:18:21 GMT</pubDate>
      <description>
      <![CDATA[<p>市场上大致分为三种公司</p>
<ul>
<li><p>第一种是项目型公司，这样的公司没有自己的产品，每次都要整个项目重新开始没有积累，所以这样的公司是赚钱最累的，这样的公司只需要项目经理。</p>
</li>
<li><p>第二种是产品型公司，这样的公司可以大批量复制产品然后卖给各地的用户，这样的公司需要产品经理和项目经理。产品经理需要把控产品从需求到销售的整个流程。</p>
</li>
<li><p>第三种公司是赚钱最轻松的，即运营型公司比如“中石油”这样的资源型垄断企业。</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>市场上大致分为三种公司</p>
<ul>
<li><p>第一种是项目型公司，这样的公司没有自己的产品，每次都要整个项目重新开始没有积累，所以这样的公司是赚钱最累的，这样的公司只需要项目经理。</p>
</li>
<li><p>第二种是产品型公司，这样的公司可以大批量复制产品然后卖给各地的用户，这样的公司需要产品经理和项目经理。产品经理需要把控产品从需求到销售的整个流程。</p>
</li>
<li><p>第三种公司是赚钱最轻松的，即运营型公司比如“中石油”这样的资源型垄断企业。</p>
<a id="more"></a>
</li>
</ul>
<p>产品经理 和 项目经理的区别？</p>
<p>先下个定义：<strong>产品经理 = Market PM  and  R&amp;D PM</strong>，即解决市场需求的项目经理 加上 研发项目经理 大致等于一个产品经理。</p>
<p>在公司前期只有一个产品的时候，公司老板基本就属于产品经理。当公司的产品多起来之后，由于老板精力有限就需要有产品经理来负责产品的整个流程。但是由于产品经理对人的要求比较高，所以有的公司用另外一个方法来替代，及市场需求方面的项目经理 加上 研发项目经理 来代替产品经理。</p>
<h3 id="项目经理的职责">项目经理的职责</h3><p>本文介绍的主要是研发项目经理，他的职责最重要的有三点：</p>
<ul>
<li>拥有良好的沟通能力。 </li>
<li>善于协调并行工作。 </li>
<li>高效决策，快速实施。</li>
</ul>
<p>其中协调并行工作非常重要，需要你做好计划，并且认识到并行工作可以大大的提高效率。</p>
<h3 id="如何锁定目标">如何锁定目标</h3><p>项目经理最需要关注的四个因素，STQC-范围、时间、质量、成本，又俗称<strong>多，快，好，省</strong>。不同的项目要求不一样，比如</p>
<blockquote>
<p>在华为最开始要抢占交换机市场的时候，时间是最重要，你的产品必须第一时间占住这个坑，因为是极短的时间做出来的产品，所以华为这个时候的交换机产品就经常出问题，经常看到华为的研发人员直接住到调试现场来弥补产品的质量问题。<br>而后期当华为的交换机产品要进军国外市场的时候，这时候产品的质量是最重要的。因为一旦质量出现问题，可能会出现一系列很严重的索赔问题。</p>
</blockquote>
<p>所以做为一个研发项目经理，首先需要对这款产品有个清晰的认识，要认识到产品最关键的因素是什么，有可能是“时间”，也可能是“质量”，也可能是“功能”。</p>
<h3 id="如何收集需求">如何收集需求</h3><p>需求收集主要来自于客户 和竞争对手。在对客户进行需求收集的时候需要注意 应该提一些广泛的、开放式的问题，比如：历史产品使用的美好回忆；使用产品失败的经历描述等。</p>
<p>一款产品只有找准定位，有所创新才有可能成功。当然如果一个类型的产品已经创新到没有什么可以创新的时候，这样情况下可能只能拼价格了，就好像目前的PC行业，索尼为什么PC业务做不下去了，而苹果的mac反而比以前卖的更好。</p>
<h3 id="如何估计工作量">如何估计工作量</h3><p>什么是工作量和工期，举个例子</p>
<blockquote>
<p>比如我一个人吃一顿饭需要半小时，那我吃饭的工作量就是半小时，然后我和另外一个人边聊天边吃饭需要两个小时，这时候我吃饭的工作量其实还是半小时，但是工期就变成两个小时了。</p>
</blockquote>
<p>工作量估计的时候</p>
<ul>
<li>应该让某项活动负责人参与该项活动的工期估计；</li>
<li>可以任命一位有经验的人进行所负责项目的工期估计； </li>
<li>历史数据可以作为参考； </li>
<li>估计应既富于挑战性，又考虑实际情况。</li>
</ul>
<h3 id="如何维护老产品">如何维护老产品</h3><p>当研发项目团队完成产品开发之后，可能需要进行新产品的开发，这时候比较好的做法就在PDT团队中挑选1~2位有经验的老员工 再带上几个新员工 组成LMT(生命周期管理团队) 对老产品进行维护。</p>
<p>这样当老产品出现问题的时候，可以先由LMT团队进行处理，形成FAQ，相当于一个防火墙的作用，这样减少对转入新产品开发的PDT团队的影响。</p>
<p>先说这么多，未完待续~~</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2014/04/20/talkAboutPM/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[浅谈WPF中的MVVM框架--MVVMFoundation]]></title>
      <link>http://fancymax.github.io/2014/04/19/%E6%B5%85%E8%B0%88WPF%E4%B8%AD%E7%9A%84MVVM%E6%A1%86%E6%9E%B6-MVVMFoundation/</link>
      <guid>http://fancymax.github.io/2014/04/19/%E6%B5%85%E8%B0%88WPF%E4%B8%AD%E7%9A%84MVVM%E6%A1%86%E6%9E%B6-MVVMFoundation/</guid>
      <pubDate>Sat, 19 Apr 2014 14:22:25 GMT</pubDate>
      <description>
      <![CDATA[<p>微软对于WPF技术的构想是很宏大的，可惜普及率不高，不过如果你要做Windows客户端开发的话WPF技术还是值得一学的。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>微软对于WPF技术的构想是很宏大的，可惜普及率不高，不过如果你要做Windows客户端开发的话WPF技术还是值得一学的。<br><a id="more"></a><br>什么是WPF，请看下图<br><img src="http://images.cnitblog.com/blog2015/708791/201504/201140330112092.jpg" alt="what is WPF" align="center"></p>
<h1 id="什么是MVVM模式">什么是MVVM模式</h1><p>简单来说它是一种高级的UI设计模式。据我所知目前还运用在一些js框架中，比如<strong>AngularJS</strong>。其他的UI设计模式还包括MVC、MVP，个人觉得最强大的还是MVVM。</p>
<p>MVVM主体框架如下图：</p>
<p><img src="http://images.cnitblog.com/blog2015/708791/201504/201225530274012.jpg" width="500" height="400" alt="what is MVVM" align="center"></p>
<blockquote>
<ul>
<li>The Model is the entity that represents the business concept; it can be anything from a simple customer entity to a complex stock trade entity .</li>
<li>The View is the graphical control or set of controls responsible for rendering the Model data on screen .A View can be a WPF window, a Silverlight page, or just an XAML data template control .</li>
<li>The ViewModel is the magic behind everything .The ViewModel contains the UI logic, the commands, the events, and a reference to the Model .</li>
<li>In MVVM, the ViewModel is not in charge of updating the data displayed in the UI—thanks to the powerful data-binding engine provided by WPF and Silverlight, the ViewModel doesn’t need to do that .This is because the View is an observer of the ViewModel, so as soon as the ViewModel changes, the UI updates itself .For that to happen, the ViewModel must implement the INotifyPropertyChangedinterface and fire the PropertyChangedevent .</li>
</ul>
</blockquote>
<p>简单翻译一下（不全）</p>
<blockquote>
<ul>
<li>The Model 代表业务逻辑的实体类，可以是一个简单的顾客实体类，也可以是一个复杂的股票交易实体类。</li>
<li>The View 代表一个用户界面控件 …</li>
<li>The ViewModel 包括各种逻辑、命令、事件以及实体类的引用。</li>
</ul>
</blockquote>
<h1 id="什么是MVVMFoundation">什么是MVVMFoundation</h1><p><a href="http://mvvmfoundation.codeplex.com" target="_blank" rel="external">MVVMFoundation</a>是一个最简单的MVVM框架，官方介绍如下：</p>
<blockquote>
<p>MVVM Foundation is a library of classes that are very useful when building applications based on the Model-View-ViewModel philosophy. The library is small and concentrated on providing only the most indispensable tools needed by most MVVM application developers</p>
</blockquote>
<p>MVVMFoundation包含四大模块：</p>
<ul>
<li><p>ObservableObject：这里相当于ViewModelBase的概念，每一个ViewModel继承自该类，调用完成之后立即释放，防止内存泄露。</p>
</li>
<li><p>RelayCommand接口：封装command的声明，包括execution执行逻辑,可选的can-execute逻辑等。外部只需要实例化并Binding就可以简单使用。</p>
</li>
<li><p>Messenger:这里主要用在各种不同的ViewModel之间通信（比如相互关联的ViewModel、主从ViewModel等），当然也可以扩展成ViewModel与View之间进行通信。</p>
</li>
<li><p>PropertyObserver：主要是对INotifyPropertyChanged.PropertyChanged进行封装，可以通过其对某个对象的属性变更注册回调函数，当属性变更时便触发回调函数。</p>
</li>
</ul>
<h1 id="ObservableObject">ObservableObject</h1><p>实现ViewModel中的属性改变通知到绑定的控件的方法，相当于是所有Viewmodel的基类。</p>
<ol>
<li><p>使用时调用OnPropertyChange方法，则后台数据变化即可通知界面刷新</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> UserName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">this</span>.user.UserName; &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.user.UserName = <span class="keyword">value</span>;</span><br><span class="line">	    OnPropertyChanged(<span class="string">"UserName"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性在View界面的绑定</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">TextBox</span> <span class="keyword">Text</span>=<span class="string">"&#123;Binding UserName&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="RelayCommand">RelayCommand</h1><p>用于在ViewModel中定义View中绑定的命令，代替了以前Winform的Click事件。</p>
<ol>
<li><p>在ViewModel中定义Command</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ICommand BrowseImageCommand</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> ICommand(BrowseImage); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">BrowseImage</span>(<span class="params"></span>)</span><br><span class="line"></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在View中的按钮关联此Command</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button <span class="variable">Content=</span><span class="string">"浏览..."</span> <span class="variable">Command=</span><span class="string">"&#123;Binding BrowseImageCommand&#125;"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="Messenger">Messenger</h1><p>可用于ViewModel之间的信息传递，可以用于ViewModel和View之间的信息传递。</p>
<ol>
<li><p>定义信息传输类</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ViewModelCommunication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ViewModelCommunication</span>(<span class="params"></span>)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        Messaging = <span class="keyword">new</span> Messenger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Messenger Messaging &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">string</span> DataIDInChanged &#123; <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="string">"DataIDInChanged"</span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在需要通知的类中注册要通知的信息</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ViewModelCommunication.Messaging.Register<span class="params">(ViewModelCommunication.DataIDInChanged,</span><br><span class="line">        <span class="params">(Action&lt;string&gt;)</span><span class="params">(param =&gt; SetLastSelectedDataID<span class="params">(param)</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当对应的消息出现时，通知已经注册的类</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ViewModelCommunication</span><span class="class">.Messaging</span><span class="class">.NotifyColleagues</span>(<span class="tag">ViewModelCommunication</span><span class="class">.DataIDInChanged</span>, </span><br><span class="line">        <span class="tag">DataID</span><span class="class">.ToString</span>());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="PropertyObserver">PropertyObserver</h1><p>主要用于对对象的属性监听，属性变更后可触发已注册的回调函数。</p>
<ol>
<li><p>注册要监听对象的属性及回调函数</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PropertyObserver&lt;UserInfoViewModel&gt; userInfoAfterObserver;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MainWindowViewModel</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    UserInfoBefore = <span class="keyword">new</span> UserInfoViewModel();</span><br><span class="line">    userInfoAfterObserver = <span class="keyword">new</span> PropertyObserver&lt;UserInfoViewModel&gt;(UserInfoAfter)</span><br><span class="line">        .RegisterHandler(UserInfo =&gt; UserInfo.Age, <span class="keyword">this</span>.AgeChangedCallback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现回调函数</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">AgeChangedCallback</span><span class="params">(UserInfoViewModel userInfo)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    MessageBox.Show(<span class="string">"Property Age changed"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上就是MVVMFoundation框架的主要使用方法，感兴趣的人可以用用看～欢迎留言交流心得～</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2014/04/19/%E6%B5%85%E8%B0%88WPF%E4%B8%AD%E7%9A%84MVVM%E6%A1%86%E6%9E%B6-MVVMFoundation/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[成长与感悟--工作两年半]]></title>
      <link>http://fancymax.github.io/2013/12/19/%E6%88%90%E9%95%BF%E4%B8%8E%E6%84%9F%E6%82%9F-%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E5%8D%8A/</link>
      <guid>http://fancymax.github.io/2013/12/19/%E6%88%90%E9%95%BF%E4%B8%8E%E6%84%9F%E6%82%9F-%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E5%8D%8A/</guid>
      <pubDate>Thu, 19 Dec 2013 14:19:18 GMT</pubDate>
      <description>
      <![CDATA[<p>13年年初的时候，机缘巧合负责了一个较大的项目。在这之前我都是单枪匹马，这是我第一次负责团队型的项目。记得当时压力很大，从3月~7月我的月平均加班时间超过了90个小时。还好最后功夫不负有心人，项目历时7个月顺利完成并部署，得到了用户的肯定。</p>
<p>以下是我在项目过程中的一些总结和思考，欢迎拍砖~</p>]]>
      
      </description>
      <content:encoded><![CDATA[<p>13年年初的时候，机缘巧合负责了一个较大的项目。在这之前我都是单枪匹马，这是我第一次负责团队型的项目。记得当时压力很大，从3月~7月我的月平均加班时间超过了90个小时。还好最后功夫不负有心人，项目历时7个月顺利完成并部署，得到了用户的肯定。</p>
<p>以下是我在项目过程中的一些总结和思考，欢迎拍砖~</p>
<a id="more"></a>
<h2 id="直接跳进深水区">直接跳进深水区</h2><p>这是学习新事物的一种最直接，也最冒险的方法。<br>选择一项新技术，比如F#，基于实际的时间表，在真实的项目中使用它。这会带来压力，但如果运用得当，将特别有效率。</p>
<p>当时我在项目的过程中，直接学习了项目管理和各种要使用的新技术，边学边用，效率奇高无比。当然压力也很大，当时想的是项目做失败就直接离职了。</p>
<h2 id="做计划的重要性">做计划的重要性</h2><p>以前做小项目的时候没有认识到计划的重要性。然后在做大项目中吃了很多亏，才认识到计划的重要性。</p>
<p>现在认识到无论是针对日常工作和学习都要有个计划。</p>
<blockquote>
<p>比如：以前我要学习一个技术，不管三七二十一马上开始，恨不得一口气吃成胖子；现在的我就会计划几个阶段，每个阶段有个目标。</p>
</blockquote>
<h2 id="一次只能做好一件事">一次只能做好一件事</h2><p>当时项目初期时分工不明确，有很多紧急的任务堆积在我身上。当时我明显感觉脑子转不过来，而且多个任务互相影响压力巨大，怎么办？</p>
<ul>
<li>我先去寻找问题的解决思路，有了思路解决后续就交给有空余时间的人处理，自己要抽身出来协调项目工作。</li>
<li>先把简单的实现，后面再集中火力攻克难关。</li>
</ul>
<p>另外保证项目组成员一个阶段只做一件事。这样提高了效率，减轻了压力，也加快了项目的进展。</p>
<h2 id="享受过程">享受过程</h2><p>需要认识到到达目标之前的曲折性。<strong>要有持续改进与提高的心态，而不是想着一开始就做的完美</strong>。<br>否则一开始就要达到完美的目标，最后极可能导致失败。</p>
<p>当时经常性的会有非常沮丧的心理，总觉得项目要失败，后来总结了以下几点安慰自己：</p>
<ul>
<li>接受现实（改变心态，告诉自已，是的我现在是克服不了，我也没有能力处理这个事情）</li>
<li>将消极的情况变为积极，找到失败的闪光点和机会（虽然的败了，这是成长的机会，让我更了解自已）</li>
<li>分心，将注意力转向别处，但不是逃避（总是执着于分析每一种感情，想法是有害的，反复思考并不一定对人有帮助，可以先听听音乐，跑跑步，与别人交流交流，回头再来思考，也许有更好的点子）。</li>
</ul>
<h2 id="关于坚持">关于坚持</h2><p>如果觉得做不下去了，就硬着头皮坚持做，然后就类似于麻木了，适应了，那种望而却步的感觉会逐渐自动退去。惊人的简单，但事实就是如此，硬着头皮，过了那个情绪上最艰难的时候，也就适应了。当然在坚持的过程中，还需要思考如何改进，如何提高效率（通过读书或向别人学习）。</p>
<h2 id="关于学习和培养兴趣">关于学习和培养兴趣</h2><p>对未来的一些规划，比如</p>
<ul>
<li>学习一门新语言</li>
<li>掌握一些通用的技术，比如正则表达式、进程间通信、文件存储 </li>
<li>掌握通用的软件思想，比如设计模式，比如MVC、MVVM </li>
<li>使用牛逼的编辑器，比如vim</li>
<li>跟踪技术博客</li>
</ul>
<p>借用一句话来结尾：</p>
<blockquote>
<p>无论怎样学习技术是一种态度，无论你在什么公司、位于何种职位、从事何种技术，学习前辈的先进方法，永远是一条最快的提升捷径。站在巨人的肩膀上，迎接世界的挑战。</p>
</blockquote>
]]></content:encoded>
      <comments>http://fancymax.github.io/2013/12/19/%E6%88%90%E9%95%BF%E4%B8%8E%E6%84%9F%E6%82%9F-%E5%B7%A5%E4%BD%9C%E4%B8%A4%E5%B9%B4%E5%8D%8A/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[我的电脑编年史]]></title>
      <link>http://fancymax.github.io/2013/09/24/myComputerHistory/</link>
      <guid>http://fancymax.github.io/2013/09/24/myComputerHistory/</guid>
      <pubDate>Tue, 24 Sep 2013 08:21:04 GMT</pubDate>
      <description>
      <![CDATA[<p>你还记得当初拥有的第一台电脑吗？<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>你还记得当初拥有的第一台电脑吗？<br><a id="more"></a></p>
<h1 id="Dell_1420">Dell 1420</h1><p>我人生的第一台电脑是大二(2008)的时候买的，6K左右。无论是打游戏,看电影,编程序,写文档都少不了它的身影，它陪我走过了整个大学时光。放张图纪念一下：<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/dell.jpg" alt="image"></p>
<h1 id="Macbook_pro">Macbook pro</h1><p>我的dell1420再用了5年左右，显卡就烧坏了。准备换个电脑，中间一直在犹豫要买什么牌子的，最后在同事的怂恿下想入手一台苹果电脑。时间是2013年9月20，正好当天苹果发布了最新的Macbook，第二天周六我就到香港买了一台15寸Macbook pro。嘿嘿，秀一下图：<br><img src="http://7xpbra.com1.z0.glb.clouddn.com/mac.jpg" alt="image"></p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2013/09/24/myComputerHistory/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[Delphi常用快捷键]]></title>
      <link>http://fancymax.github.io/2012/12/19/Delphi%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</link>
      <guid>http://fancymax.github.io/2012/12/19/Delphi%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</guid>
      <pubDate>Wed, 19 Dec 2012 14:26:49 GMT</pubDate>
      <description>
      <![CDATA[<p>delphi是我学编程时的入门语言，用过一年多的时光，个人对它还是挺喜欢的。现在用的少了，一些快捷键和语法也有些遗忘了，这里对delphi的快捷键做个总结，留个纪念。嘿嘿，不知道还有多少人还用着这门语言？<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>delphi是我学编程时的入门语言，用过一年多的时光，个人对它还是挺喜欢的。现在用的少了，一些快捷键和语法也有些遗忘了，这里对delphi的快捷键做个总结，留个纪念。嘿嘿，不知道还有多少人还用着这门语言？<br><a id="more"></a></p>
<h1 id="代码标记和切换_Ctrl+Shift+NUM_、_Ctrl+NUM">代码标记和切换   Ctrl+Shift+NUM 、  Ctrl+NUM</h1><ul>
<li><p>Ctrl+Shift+NUM 在光标行设置最多九个临时标志号，对临时切换非常有用。<br>行的左边将出现一本书，封面有NUM，再按一次取消设置。</p>
</li>
<li><p>Ctrl+NUM 直接将光标跳到NUM处，NUM是用Ctrl+Shift+NUM设置的标号, NUM不能用小键盘。</p>
</li>
</ul>
<p><img src="http://images.cnitblog.com/blog2015/708791/201505/082022001733856.gif" alt="mark.gif">    </p>
<h1 id="光标移至文件头、文件尾_Ctrl+Home_、Ctrl+End">光标移至文件头、文件尾   Ctrl+Home 、Ctrl+End</h1><p> <img src="http://images.cnitblog.com/blog2015/708791/201505/082020126261379.gif" alt="jumpHome.gif"></p>
<h1 id="删除光标所在行_Ctrl+Y">删除光标所在行  Ctrl+Y</h1><p><img src="http://images.cnitblog.com/blog2015/708791/201505/082019273297683.gif" alt="/delete1.gif"></p>
<h1 id="光标在函数声明和函数定义处跳转_Ctrl+Shift+↓_、Ctrl+Shift+↑">光标在函数声明和函数定义处跳转  Ctrl+Shift+↓ 、Ctrl+Shift+↑</h1><p>光标在函数体内时，将光标快速移至当前函数声明处，反之亦然。<br><img src="http://images.cnitblog.com/blog2015/708791/201505/082020589237901.gif" alt="jumpmethod.gif"></p>
<h1 id="声明一个过程或函数后，直接生成过程或函数的名称_Ctrl+Shift+C">声明一个过程或函数后，直接生成过程或函数的名称  Ctrl+Shift+C</h1><p><img src="http://images.cnitblog.com/blog2015/708791/201505/081952484074730.gif" alt="createmethod.gif">   </p>
<h1 id="加速滚屏_Ctrl+鼠标转轮">加速滚屏    Ctrl+鼠标转轮</h1><h1 id="按住Alt,再进行选择,则是一种区域选择">按住Alt,再进行选择,则是一种区域选择</h1><p><img src="http://images.cnitblog.com/blog2015/708791/201505/082022422519367.gif" alt="select.gif"></p>
<h1 id="调试相关">调试相关</h1><p>F9  运行 </p>
<p>F8  StepOver </p>
<p>F7  TraceInto</p>
<p>F11,F12切换Editor,InSpector,FormDesigner.</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2012/12/19/Delphi%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/#disqus_thread</comments>
    </item>
    
    <item>
      <title><![CDATA[成长与感悟--工作一年半]]></title>
      <link>http://fancymax.github.io/2012/12/19/%E6%88%90%E9%95%BF%E4%B8%8E%E6%84%9F%E6%82%9F-%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A/</link>
      <guid>http://fancymax.github.io/2012/12/19/%E6%88%90%E9%95%BF%E4%B8%8E%E6%84%9F%E6%82%9F-%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A/</guid>
      <pubDate>Wed, 19 Dec 2012 14:13:36 GMT</pubDate>
      <description>
      <![CDATA[<p>2012年年底写的总结，拿出来和大家分享一下。<br>]]>
      
      </description>
      <content:encoded><![CDATA[<p>2012年年底写的总结，拿出来和大家分享一下。<br><a id="more"></a></p>
<h2 id="从找工作说起">从找工作说起</h2><p>本人自动化专业出身，本科毕业的时候，大部分同学都进了电厂做运行或检修，而我算是个另类。</p>
<p>主因是在大三的时候做了几个嵌入式项目，发现自己对编程很感兴趣，于是毅然决然想当个程序猿。毕业的时候凭着C语言和单片机的一点基础，找到了一家做行业软件的公司，感觉还蛮幸运的。</p>
<h2 id="入职初期">入职初期</h2><p>真正进入到部门大概是2011年八月中旬的样子。刚开始工作的时候座位排在部门经理和一位老员工中间倍感压力山大。</p>
<p>但是压力大，兴趣也大。虽然一开始什么也不懂，但是通过自己的努力慢慢弥补上了，加上大家的指导，很快进入状态。软件部的人也基本上是<strong>知无不言，言无不尽</strong>。</p>
<p>部门领导虽然平常很忙，但是心思细腻，经常会回复我的工作总结给我建议，还会教我一些小窍门，感觉备受鼓舞。</p>
<h2 id="一切从模仿开始">一切从模仿开始</h2><p>在我打好基础之后，就开始带着任务学习，感觉这是一种能够快速成长的方法。通过参与程序的BUG修改，了解老程序的原理。通过模仿然后举一反三可以自己编写程序。经过时间的积累，量变到质变，就可以在已有程序的基础上进行创新。</p>
<h2 id="重新学习自己需要的东西">重新学习自己需要的东西</h2><p>大学的时候主要用C语言，工作之后接触delphi是pascal语法，代码段之间需要使用begin和end包含起来，一开始很不适应，觉得很不简洁。可是等自己真正开始了解并熟悉这个语言的时候，我反而觉得begin和end包含代码段使程序结构变得特别清晰易懂，使用起来也挺顺手的。</p>
<h2 id="要学会“问”的技巧">要学会“问”的技巧</h2><p>当然也总结一些问问题的技巧：</p>
<ol>
<li>问对人，你要问的人，他必须对这个问题比较擅长，否则浪费两个人的时间。</li>
<li>选好时间，不要选择人家非常忙的时候问。</li>
<li>找准问题，能在google上找到答案的问题就不要问了。遇到特别棘手的问题无法解决的时候，一个比较好的办法就是收集尽量多的材料，把问题描述清楚，让更多的人参与进来给你一些建议，人多力量大，结合的意见越多越容易找到解决办法。</li>
</ol>
<h2 id="遇到困难，积极面对">遇到困难，积极面对</h2><p>工作中总会遇到各种各样的困难，消极对待只会越来越痛苦，反之积极面对最后战胜困难就很有成就感。</p>
<blockquote>
<p>之前提交程序，要修改成5个不同的版本提交到svn的不同的路径，一个流程下来花10分钟，特痛苦。</p>
<p>仔细想想，这个提交exe流程其实是一个重复的过程，为何不写一个程序让它自动执行呢？后来我花了一个星期用Python写了一个自动化提交的脚本，之后大家都用它愉快的提交程序了。</p>
</blockquote>
<h2 id="与第三方厂家沟通">与第三方厂家沟通</h2><p>有时候涉及到与第三方厂家的沟通，说实话比较痛苦。</p>
<p>这时候要有诚意，表现出互利共赢的态度，描述问题要清楚，对第三方装置有疑问，首先要确认不是自己错了，然后需要找好证据，比如要用以太网抓包工具收集底层报文的证据，而不要使用程序中的调试信息。</p>
<p>诚恳的态度永远是最好的沟通方法。当然也会遇到完全不买帐的第三方厂家，这时候就需要寻求帮助，找相关人员协助，不要自己一个人闷头痛苦。</p>
<h2 id="后记">后记</h2><p>现在想来特别羡慕当时的工作状态，感觉每天都在进步。这种状态或许再也找不回来了，又或者等我换家公司的时候能体会到？</p>
]]></content:encoded>
      <comments>http://fancymax.github.io/2012/12/19/%E6%88%90%E9%95%BF%E4%B8%8E%E6%84%9F%E6%82%9F-%E5%B7%A5%E4%BD%9C%E4%B8%80%E5%B9%B4%E5%8D%8A/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
